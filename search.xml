<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cosmic估算方法学习笔记</title>
      <link href="/cosmic-gu-suan-fang-fa-xue-xi-bi-ji/"/>
      <url>/cosmic-gu-suan-fang-fa-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="Cosmic-估算方法简介"><a href="#Cosmic-估算方法简介" class="headerlink" title="Cosmic 估算方法简介"></a>Cosmic 估算方法简介</h3><p><a href="http://www.measures.net.cn/UploadedFiles/15548924688853944COSMIC%20Method%20v4.0.1%20Introduction%20to%20COSMIC%20v1.1-CH.pdf">COSMIC 软件度量方法简介</a></p><p>简单来说该方法是以数功能点的方式来预估项目工作量。把一个最小颗粒度的 story 拆分成 EXRW（输入、输出、读取、写入）4种功能点，最后再汇总统计来计算总工程量。</p><img src="/cosmic-gu-suan-fang-fa-xue-xi-bi-ji/EXRW-example.png" class="" title="[举例]"><h3 id="关于优缺点的思考"><a href="#关于优缺点的思考" class="headerlink" title="关于优缺点的思考"></a>关于优缺点的思考</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>快速，简便，通用</p><p>门槛低不需要专业人员参与，有助于和客户沟通确认实际需求，解释工作量。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>改造、升级类项目的评估没有明显优势，可能难以适用。</p><p>内部逻辑复杂的项目恐怕难以适用，比如一个项目某个重点技术难点就要占据整个项目很大一部分时间的情况。</p><h3 id="关于工程量估算的思考"><a href="#关于工程量估算的思考" class="headerlink" title="关于工程量估算的思考"></a>关于工程量估算的思考</h3><p>敝人本专业是建筑环境与设备工程，我一直都在思考一个问题，为什么软件行业至今没有发展出像建筑工程行业一样成熟的项目估算，进度控制方法。</p><p>同时这个问题也可以转化成为什么建筑行业的成熟方法没有被套用在软件行业上。“人机料法环”六字真言多么顺耳。</p><p>大胆猜测之一，行业壁垒可能让两个行业缺乏顶层交流，软件行业可能从来不知道有这些方法可以借用。</p><p>但我认为这种可能性非常小，行业先贤在拓荒阶段肯定考虑过借鉴学习。大概率还是因为行业情况不同。建筑行业对质量的要求跟 IT 行业大部分情况下根本不是一个级别的。你不可能把一栋楼盖完住户入住之后再每个月升级打补丁。</p><p>还有就是 IT 行业的产品往往要求快速的研发发布抢占市场。</p><p>但我个人觉得以上的两种差别情况实际正在减少。IT 行业的渗透率越来越高，蓝海市场越来越少。红海市场的厮杀应该是质量、成本取胜而非速度。随着 IT 行业继续深入传统行业比如互联网+概念，汽车，飞机这些场景都需要堪比建筑行业的质量要求。理论上将来我们可能真有可能见到把建筑行业的工程管理方法引入到 IT 行业的一天。</p><p>回到 IT 行业的估算工作上来，就过往的经验来说估算不准确的情况 50% 因为需求不明确 40% 你估你的Boss就要下月交 9% 估算人员太过乐观 1% 估算人员过于悲观。就 90% 的情况来说你用什么方法根本不重要。就Cosmic 方法来说，能够增加和用户沟通便捷性，方便挖掘用户需求这方面来说，确实有其价值。也就是说对于交付甲方性质的项目有用，对于自研项目个人认为没有特别优势或劣势。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钱够用</title>
      <link href="/qian-gou-yong/"/>
      <url>/qian-gou-yong/</url>
      
        <content type="html"><![CDATA[<p>经济学里面有一些常见的理论：适当的通胀可以刺激经济的发展。货币供应量需要符合市场流通的商品总量，如果货币量不足会影响市场的交易正常进行。这些理论导向一个结果——国家需要印钞，不断的加大货币供应量。</p><p>真的是如此吗？西太平洋上有个小岛，岛上的居民用一块大石头当作货币。今天张家卖给李家两只鸡售价是这块石头的千分之一，明天李家卖给赵家两只鸭售价是千分之二。看起来并无什么不妥。他们会遇到货币不足的情况吗？也就是说只要货币无限可分，哪怕全国只有一块钱也足够十亿人使用。</p><p>通胀可以刺激经济的发展？岛国日本过去几十年印了无数的钱，发了无数的债试图刺激经济。但几乎没有效果。这个观点的逻辑是这样的。因为通胀你手里的存款会持续减少，人不管是为了满足自己的基本生存需求还是更高级的追求都必须付出劳动努力去挣钱。大家更努力的工作了，经济也就发展了。所以这招在一个全民低欲望的社会里面失效了。可见促使社会发展的根本原因是人民的主观能动性，是科技、技术、劳动产生的生产力提高，而非什么通胀。</p><p>那么为什么会有这些理论，并且这些理论也确实主导着当今世界呢？</p><p>以下纯属个人臆想。</p><p>正如法律是统治阶级意志的体现。很多经济学家，新闻机构同样服务于统治阶级。自古以来没有比收铸币税更快的敛财方式了。为了使这一切合理化，还需要一套完整理论支撑其观点，美化其观点。所以一帮对人类社会毫无正面贡献的经济“学家”“编”出了一大堆的理论来忽悠世人。</p><p>下面开始民科暴论，经济学人请立刻撤离。</p><p>经济学不是科学，它没有任何公式可以带入现实进行任何有用的演算验证。气象学家可以预测明天的天气，经济学家炒股亏钱。</p><p>我认为人类不需要通胀，不需要经济学家，不需要金融杠杆，不需要任何金融衍生品。这些通通都是统治阶级以及附庸在统治阶级下的精英阶级的敛财工具。他们非但不能促进社会发展，还只会加大社会贫富差距阻碍社会发展进步。一个能够快速发展的社会应该是人民对生活充满希望的社会，而不是面对阶级鸿沟只感到绝望的社会。</p><p>总结，钱够用。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人性的等级</title>
      <link href="/ren-xing-de-deng-ji/"/>
      <url>/ren-xing-de-deng-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="道德评判标准"><a href="#道德评判标准" class="headerlink" title="道德评判标准"></a>道德评判标准</h2><p>你可能听过这样的观点，穷人的素质比富人差。事实是否真的如此？我对这个问题没有答案。</p><p>但是我相信经济基础决定上层建筑。这个上层建筑可以包含道德善良等概念。</p><p>因为物质的贫乏，人类可能会变得更加好斗，这应是生物的本能，生存是第一需求。</p><p>故，我认为对人的道德的评价理应基于其生存状况和经济情况。情况越好，标准越高。情况越差，标准越低。</p><p>列举一些极端的例子。犹太人当年在集中营当中为了生存发生了很多残害同胞的行为，这种行为是否应当被原谅。亿万富豪，捐出了自己 1% 的财产给穷人，这种行为是否值得表扬。只顾自己对社会毫无贡献甚至有害的是否应该被唾弃。</p><p>佛洛依德主张人有本我、自我超我。将其运用在这个问题上，当生存环境越恶劣时，人的行为越趋向于原始的兽性。当人的生理需求、安全需求得到满足时，我们才能把一个人当作人来对其进行要求。同时如果一个人的生理需求和安全需求都得不到满足时还能表现出极高的道德准测的，可以称之为圣人。</p><h2 id="生理需求"><a href="#生理需求" class="headerlink" title="生理需求"></a>生理需求</h2><p>我个人认为性需求是需要单独说明的一个。显然性需求属于生理需求，但是现在社会常常将其从正常的生理需求中刨去。出于求生欲，事先声明我没有任何为猥亵，强奸犯辩护的意思。只是当今社会有些法律限制私以为不太合理。</p><p>理想社会当中人人都能找到自己的另一半，从而解决性需求。我认为非理想状态下的现今社会应当建设尽量满足性资源匮乏群体的社会制度。尽量的意思是我不同意妓女或男妓的合法化。无论如何为这种古老职业辩解，这项职业始终对从业者的尊重需求有伤害，妨碍了从事这项职业人的真正自我实现。这份职业必然是往理想社会前进道路上的障碍。</p><p>尽量满足人的性需求其实还有很多其他的办法。例如，色情制品。包括但不限于影像，音频，文字，动画等等。私以为禁止这些产品就像禁酒一样糟糕。可能有人会说影像制品一样会对从业人员有伤害。我想说确实，但是我们还可以通过各种手段来保护从业人员将这种伤害降到最小甚至没有。一是个人隐私保护，二是现在的 CG AI 换脸等技术。日本已经有过关于 AV 产业对于降低性犯罪率的研究，这里不再详述。</p><h2 id="理想社会"><a href="#理想社会" class="headerlink" title="理想社会"></a>理想社会</h2><p>理想社会的第一步应当是每个人的生理需求、安全需求都得到了满足。在此基础上每个人去追求各自的自我实现。我想这就是马克思主义的每个人都可以充分自由发展的社会。</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>重点强调，对人的道德评判应该基于其生存状况。不能用同一把尺去衡量当今社会的所有人这是不公平的。至少也应做到从生理需求加安全需求是否得到满足这条分界线来制定不同的评判标准。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔试选择题</title>
      <link href="/qian-duan-bi-shi-xuan-ze-ti/"/>
      <url>/qian-duan-bi-shi-xuan-ze-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><h5 id="1、控制台输出的结果是？"><a href="#1、控制台输出的结果是？" class="headerlink" title="1、控制台输出的结果是？"></a>1、控制台输出的结果是？</h5><pre><code>var arraynew = new Array(5)arraynew[1]=1arraynew[5]=2console.log(arraynew.length)</code></pre><p>A、0<br>B、1<br>C、5<br>D、6  </p><h5 id="2、在-css-选择器当中，优先级排序正确的是（）"><a href="#2、在-css-选择器当中，优先级排序正确的是（）" class="headerlink" title="2、在 css 选择器当中，优先级排序正确的是（）"></a>2、在 css 选择器当中，优先级排序正确的是（）</h5><p>A、id选择器&gt;标签选择器&gt;类选择器<br>B、标签选择器&gt;类选择器&gt;id选择器<br>C、类选择器&gt;标签选择器&gt;id选择器<br>D、id选择器&gt;类选择器&gt;标签选择器</p><h5 id="3、CSS-样式，下面哪一个元素能够达到最大宽度，且前后各有一个换行？（-）"><a href="#3、CSS-样式，下面哪一个元素能够达到最大宽度，且前后各有一个换行？（-）" class="headerlink" title="3、CSS 样式，下面哪一个元素能够达到最大宽度，且前后各有一个换行？（ ）"></a>3、CSS 样式，下面哪一个元素能够达到最大宽度，且前后各有一个换行？（ ）</h5><p>A、Block Element<br>B、Square Element<br>C、Side Element<br>D、Box Elemen</p><h5 id="4、JavaScript中window对象的子对象不包含以下哪个对象？（-）"><a href="#4、JavaScript中window对象的子对象不包含以下哪个对象？（-）" class="headerlink" title="4、JavaScript中window对象的子对象不包含以下哪个对象？（ ）"></a>4、JavaScript中window对象的子对象不包含以下哪个对象？（ ）</h5><p>A. document   B. self   C. history   D. message</p><h5 id="5、下边代码输出的结果是（-）"><a href="#5、下边代码输出的结果是（-）" class="headerlink" title="5、下边代码输出的结果是（ ）"></a>5、下边代码输出的结果是（ ）</h5><pre><code>var val = &#39;smtg&#39;;console.log(&#39;Value is &#39; + (val === &#39;smtg&#39;) ? &#39;Something&#39; : &#39;Nothing&#39;);</code></pre><p>A: Value is Something<br>B: Value is Nothing<br>C: NaN<br>D: other</p><h5 id="6、下边代码输出的结果是（-）"><a href="#6、下边代码输出的结果是（-）" class="headerlink" title="6、下边代码输出的结果是（ ）"></a>6、下边代码输出的结果是（ ）</h5><pre><code>var name = &#39;World!&#39;;(function () &#123;    if (typeof name === &#39;undefined&#39;) &#123;        var name = &#39;Jack&#39;;        console.log(&#39;Goodbye &#39; + name);    &#125; else &#123;        console.log(&#39;Hello &#39; + name);    &#125;&#125;)(); </code></pre><p>A: Goodbye Jack<br>B: Hello Jack<br>C: Hello undefined<br>D: Hello World</p><h5 id="7、下列事件哪个不是由鼠标触发的事件（）"><a href="#7、下列事件哪个不是由鼠标触发的事件（）" class="headerlink" title="7、下列事件哪个不是由鼠标触发的事件（）"></a>7、下列事件哪个不是由鼠标触发的事件（）</h5><p>A、click<br>B、contextmenu<br>C、mouseout<br>D、keydown</p><h5 id="8、下列不属于javascript内置对象的是（-）"><a href="#8、下列不属于javascript内置对象的是（-）" class="headerlink" title="8、下列不属于javascript内置对象的是（ ）"></a>8、下列不属于javascript内置对象的是（ ）</h5><p>A、Math<br>B、Date<br>C、RegExp<br>D、Window<br>E、Error</p><h5 id="9、以下运行结果（-）"><a href="#9、以下运行结果（-）" class="headerlink" title="9、以下运行结果（ ）"></a>9、以下运行结果（ ）</h5><pre><code>for(var i = 0; i &lt; 10; i++) &#123;    setTimeout(function() &#123;        console.log(i);    &#125;, 1000);&#125;</code></pre><p>A、0–9<br>B、10个10<br>C、10个9<br>D、无限循环</p><h3 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h3><h5 id="10、input元素的type属性的取值可以是"><a href="#10、input元素的type属性的取值可以是" class="headerlink" title="10、input元素的type属性的取值可以是( )"></a>10、input元素的type属性的取值可以是( )</h5><p>A、image<br>B、checkbox<br>C、button<br>D、select</p><h5 id="11、下列关于web页面级优化描述最正确的是（-）"><a href="#11、下列关于web页面级优化描述最正确的是（-）" class="headerlink" title="11、下列关于web页面级优化描述最正确的是（ ）"></a>11、下列关于web页面级优化描述最正确的是（ ）</h5><p>A、减少HTTP请求的次数<br>B、进行资源合拼和压缩<br>C、Inline images<br>D、将外部脚本置于低端<br>E、减少不必要的HTTP跳转<br>F、以上描述都对</p><h5 id="12、函数的调用方式有哪些：（-）"><a href="#12、函数的调用方式有哪些：（-）" class="headerlink" title="12、函数的调用方式有哪些：（ ）"></a>12、函数的调用方式有哪些：（ ）</h5><p>A、直接调用<br>B、作为对象方法调用<br>C、作为构造函数调用<br>D、通过call和apply方法调用</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.cn/post/6844904040342487048">80道前端面试选择题</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试提纲</title>
      <link href="/qian-duan-mian-shi-ti-gang/"/>
      <url>/qian-duan-mian-shi-ti-gang/</url>
      
        <content type="html"><![CDATA[<h3 id="样式CSS"><a href="#样式CSS" class="headerlink" title="样式CSS"></a>样式CSS</h3><ol><li>实现垂直居中</li><li>自适应布局 flex Grid</li><li>动画</li><li>canvas</li></ol><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ol><li>原型链，作用域，闭包</li><li>ES6，Pormise，async</li><li>设计模式，工厂、适配器、桥接</li><li>动态数据绑定的实现原理</li><li>全局状态管理 redux vuex</li><li>TypeScript</li><li>js 事件机制</li></ol><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ol><li>组件化理解</li><li>Virtual Dom</li><li>shadow dom</li></ol><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><ol><li>工程化的理解</li><li>webpack loader</li><li>异步加载的实现原理</li><li>CSS-module less sass</li><li>代码质量保障</li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>服务端渲染</li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h3 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h3><h3 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>加班接受情况</li><li>职业规划</li><li>前端现状及未来走向</li><li>学习能力</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 装饰器，一篇就够</title>
      <link href="/js-zhuang-shi-qi-yi-pian-jiu-gou/"/>
      <url>/js-zhuang-shi-qi-yi-pian-jiu-gou/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000014495089">原文地址</a></p><h3 id="相关历史"><a href="#相关历史" class="headerlink" title="相关历史"></a>相关历史</h3><p>三年多以前，Yehuda Katz 首先提出了装饰器的概念。TypeScript 在 1.5 版本（2015）中发布了对装饰器的支持以及许多 ES6 的相关特性。 一些主流框架，如 Angular 和 MobX 等开始使用它们来增加开发者体验：这使得装饰器非常受欢迎，并给社区带来了一种已经稳定的错觉。</p><p>Babel 第一次实现装饰器是在 v5 版本中，但由于该提案仍在不断变化，则在 Babel v6 中移除了它们。Logan Smyth 创建了一个非官方的插件(babel-plugin-transform-decorators-legacy)，它延用了 Babel 5 中装饰器的行为；在 Babel 7 的 alpha 版本发布期间该库被移至 Babel 官方的仓库中。当时该插件仍使用旧的装饰器语法，因为新提案尚未明确。</p><p>自那时起，Daniel Ehrenberg、Brian Terlson 以及 Yehuda Katz 就一起成为了该提案的共同作者，该提案几乎已被完全重写。当然并非一切事情都已确定，因为至今尚未出现符合规范的实现方式。</p><p>Babel 7.0.0 为 @babel/plugin-proposal-decorators 插件引入了新的标识：legacy 选项，其唯一有效值为 true。这种突破性变更是必要的，它为提案从第一阶段到当前阶段平稳过渡作铺垫。</p><p>在 Babel 7.1.0 中，我们引入了对这个新提案的支持，并且当 @babel/plugin-proposal-decorators 插件被使用时，默认启用。而在 Babel 7.0.0 中如果我们不设置 legacy: true 选项，默认情况下就不能使用该语义（相当于 legacy: false）。</p><p>新提案同时支持使用装饰器实现私有字段（private fields）和私有方法（private methods）。我们尚未在 Babel 中实现此功能（在每个 class 中使用装饰器或私有元素），但我们会很快去出现它。</p><h3 id="装饰器函数相关参数"><a href="#装饰器函数相关参数" class="headerlink" title="装饰器函数相关参数"></a>装饰器函数相关参数</h3><p>新提案提出的第三个重要变化与传递给装饰器函数参数相关。</p><p>在提案的第一个版本中，类元素装饰器接收的参数分别为目标类（或对象），key 以及属性描述符 - 与传递给 Object.defineProperty 的形式类似。类装饰器将目标构造函数（constructor）作为唯一参数。</p><p>新的装饰器提案更加强大：元素装饰器会接收一个对象，该对象除更改属性描述符外，还允许更改 key 值，可以赋值（static，prototype 或者 own），以及元素的类型（field 或 method）。它们还可以创建其他属性并在装饰类上定义运行函数（完成器）。</p><p>类装饰器接收一个包含类描述符的对象，使得类在创建之前修改它们成为可能。</p>]]></content>
      
      
      <categories>
          
          <category> 转帖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转帖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超越“双十一” | ebay支付核心账务系统架构演进之路</title>
      <link href="/chao-yue-shuang-shi-yi-ebay-zhi-fu-he-xin-zhang-wu-xi-tong-jia-gou-yan-jin-zhi-lu/"/>
      <url>/chao-yue-shuang-shi-yi-ebay-zhi-fu-he-xin-zhang-wu-xi-tong-jia-gou-yan-jin-zhi-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;mid=2650508843&amp;idx=1&amp;sn=b43da4c2691cab6e67f66d90a7154024&amp;chksm=8731b67fb0463f691d00b37dda441eee867840a97f58da139478d91c87bedc8c555b5966051a&amp;mpshare=1&amp;scene=1&amp;srcid=1111dorUEZMrqUObEmt9pSFC&amp;sharer_sharetime=1605079313227&amp;sharer_shareid=c164250d55ff1c22193854cb6ee7b0c2&amp;key=f3ad4f79e700da4eef832e74dc10e5a779d724f270e4c34cb131e1774eaff6ae76472b2ecb4c69c122b3790d4a2c3788131943f6bc2ca0f49d2069c91820ed77e60a7c262a0d85b12a7706f9b650116e571ee5c2206429734b8f06f6283f53ca8f20eb9b93cc4e9a59dd194d101d98bdfab16020188c067cc5ec54468d7ee1b1&amp;ascene=1&amp;uin=NzY4NTQ4NzAw&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=AbsFHJbcAietBqTdhhQmkg0%3D&amp;pass_ticket=ptWTlQB0SwEZADN047ELwmNuu5HtT0NS2EkXVZ8fhcxVeD%2B%2FXUmTw50KD2ltpksO&amp;wx_header=0">原文地址</a></p><blockquote><p>ebay支付新一代核心账务系统FAS（Financial Accounting System）自今年3月上线以来，帮助全球百万卖家处理交易合计超百亿条，日均实时处理线上千万支付流量，每日payout金额超千万美元。系统上线至今稳定运行，并成功做到“三无”：无一次数据丢失，无一次转账错误，无一次整体宕机。系统后台仅由5台普通计算机组成，对硬件资源要求极低，且几乎无需运维。本文旨在介绍该系统背后的架构演进，希望为大家解决同类问题提供一种不一样的思路。</p></blockquote><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p>[1]<a href="https://raft.github.io/">https://raft.github.io/</a><br>[2]<a href="https://martinfowler.com/bliki/DomainDrivenDesign.html">https://martinfowler.com/bliki/DomainDrivenDesign.html</a><br>[3]<a href="https://martinfowler.com/eaaDev/EventSourcing.html">https://martinfowler.com/eaaDev/EventSourcing.html</a><br>[4]<a href="https://rocksdb.org/">https://rocksdb.org/</a><br>[5]<a href="https://github.com/Netflix/chaosmonkey">https://github.com/Netflix/chaosmonkey</a><br>[6]<a href="https://github.com/eBay/Gringofts">https://github.com/eBay/Gringofts</a></p>]]></content>
      
      
      <categories>
          
          <category> 转帖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转帖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft算法</title>
      <link href="/raft-suan-fa/"/>
      <url>/raft-suan-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/8e4bbe7e276c">原文地址</a></p><blockquote><p>拜占庭将军问题是分布式领域最复杂、最严格的容错模型。但在日常工作中使用的分布式系统面对的问题不会那么复杂，更多的是计算机故障挂掉了，或者网络通信问题而没法传递信息，这种情况不考虑计算机之间互相发送恶意信息，极大简化了系统对容错的要求，最主要的是达到一致性。</p></blockquote><h3 id="针对简化版拜占庭将军问题，Raft-解决方案类比"><a href="#针对简化版拜占庭将军问题，Raft-解决方案类比" class="headerlink" title="针对简化版拜占庭将军问题，Raft 解决方案类比"></a>针对简化版拜占庭将军问题，Raft 解决方案类比</h3><blockquote><p>假设将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成一致性决定？</p></blockquote><p>Raft 的解决方案大概可以理解成 先在所有将军中选出一个大将军，所有的决定由大将军来做。选举环节：比如说现在一共有3个将军 A, B, C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就会把自己当成大将军候选人，然后派信使去问其他几个将军，能不能选我为总将军？假设现在将军A倒计时结束了，他派信使传递选举投票的信息给将军B和C，如果将军B和C还没把自己当成候选人（倒计时还没有结束），并且没有把选举票投给其他，他们把票投给将军A，信使在回到将军A时，将军A知道自己收到了足够的票数，成为了大将军。在这之后，是否要进攻就由大将军决定，然后派信使去通知另外两个将军，如果在一段时间后还没有收到回复（可能信使被暗杀），那就再重派一个信使，直到收到回复。</p><p>………………</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>Raft 是能够实现分布式系统强一致性的算法，每个系统节点有三种状态 Follower，Candidate，Leader。实现 Raft 算法两个最重要的事是：选主和复制日志</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>Raft 官网：<a href="https://raft.github.io/">https://raft.github.io/</a></p><p>Raft 原理动画 (推荐看看)：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p>Raft 算法解析图片来源：<a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd">http://www.infoq.com/cn/articles/coreos-analyse-etcd</a></p>]]></content>
      
      
      <categories>
          
          <category> 转帖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转帖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果 Safari 做不到对，快有何用？</title>
      <link href="/ru-guo-safari-zuo-bu-dao-dui-kuai-you-he-yong/"/>
      <url>/ru-guo-safari-zuo-bu-dao-dui-kuai-you-he-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="一个困扰了一周的-bug"><a href="#一个困扰了一周的-bug" class="headerlink" title="一个困扰了一周的 bug"></a>一个困扰了一周的 bug</h3><p>2016 年的一天，当我们发现 iPhone 上的浏览器不能正确通过我们的 CDN 鉴权后，我们花了数天的时间来 debug。简单来说当时的情况是，我们需要同时上传 3 个文件，我们会用用户 token 来换 3 个独立的随机数 id，这三个 id 会被 CDN 服务器认为合法，用户可以直接上传到 CDN 上而无需在我们自己服务器上中转。<br>但 iOS 用户很快就出现了一个奇怪的问题，用户 3 个文件只能成功上传 1 个，剩下 2 个无法正常上传。再进一步调试后我们发现，在上传任意一个文件后，剩下两个 id 变成了非法。再进一步地，我们发现 Safari 获得的 3 个 id 竟然是完全相同的？！<br>复现<br>我很快设计出了能够构建出这个问题的重现：</p><p><a href="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what/">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 转帖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转帖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter应用开发demo展示</title>
      <link href="/flutter-ying-yong-kai-fa-demo-zhan-shi/"/>
      <url>/flutter-ying-yong-kai-fa-demo-zhan-shi/</url>
      
        <content type="html"><![CDATA[<p>真实后台环境下录制<br><img src="/flutter-ying-yong-kai-fa-demo-zhan-shi/pet_plante_demo.gif" class=""></p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题分享</title>
      <link href="/mian-shi-ti-fen-xiang/"/>
      <url>/mian-shi-ti-fen-xiang/</url>
      
        <content type="html"><![CDATA[<p>今天做了几道面试题，分享一下</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>解释：</p><pre><code>var a = &#123; name: &quot;hello&quot; &#125;, b = &#123; name: &quot;hi&quot; &#125;function exchange(a, b) &#123;  var c = b; b = a; a = c;  a.name = a.name + &quot;1&quot;;  b.name = b.name + &quot;2&quot;;  console.info(a.name, b.name);&#125;exchange(a, b);console.info(a.name, b.name);</code></pre><p>答：</p><pre><code>var a = &#123;  name: &quot;hello&quot;&#125;, b = &#123; name: &quot;hi&quot; &#125;function exchange(a1, b1) &#123;  /**   * 传参进函数内部，JS 会创建参数的副本，这里用 a1, b1 指代副本，   * 但若参数是对象，拷贝的只是指针。   */  var c = b1;   b1 = a1; // b1 等于 a  a1 = c; // a1 等于 b  a1.name = a1.name + &quot;1&quot;; // b.name 等于 hi1  b1.name = b1.name + &quot;2&quot;; // a.name 等于 hello2  /**   * a1.name 被赋值的同时， b.name 也被赋值，因为此时 a1 和 b 指向的是同一个对象。   * 下面执行 console.log(a1 === b) 可以确定   */  console.log(a1 === b)  // a1.name 等于 b.name 等于 hi1  // b1.name 等于 a.name 等于 hello2   console.info(a1.name, b1.name);&#125;exchange(a, b); // hi1 hello2console.info(a.name, b.name); // hello2 hi1</code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p>时间比较题:输入一组时间字符串，求出这组时间中的间隔最小的时间差（分），如输入 “23:59”,”00:00”，返回1 ; 假设输入数组的长度大于2且小于2000; (本题可以写伪代码)</p><pre><code>/** * @param &#123;string[]&#125; timePoints * @return &#123;number&#125; */var findMinDifference = function (timePoints) &#123;  const timeTicks = new Array(1440).fill(0);  for (let point of timePoints) &#123;    const [hour, min] = point.split(&#39;:&#39;);    const minutes = parseInt(hour) * 60 + parseInt(min);    if (timeTicks[minutes] === 1) &#123;      return 0;     &#125;    timeTicks[minutes] += 1  &#125;  let first;  let prev;  let min = Infinity;  for (let i = 0; i &lt; timeTicks.length; i++) &#123;    if (timeTicks[i] === 1) &#123;      if (first === undefined) &#123;        first = i;      &#125;      if (prev !== undefined) &#123;        // 比较两组存在的时间之间的差值        min = Math.min(i - prev, min);      &#125;      prev = i;    &#125;  &#125;  // 比较头尾的差值  return Math.min(min, 1440 - prev + first);&#125;;var result = findMinDifference([&#39;00:00&#39;, &#39;00:01&#39;, &#39;12:59&#39;, &#39;23:58&#39;,])console.log(result) // 1</code></pre><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><p>假如有一个接口getUersById(userId),返回用户信息的json; 要求getUersById能缓存用户信息，即同样的userId请求仅向服务器发送一次,其余从内存中获取,以提高效率。 高阶要求: 假设有getUersById，getShoolInfoById, getDeviceInfoById … 都需要缓存结果，提供一个通用的 辅助 函数。</p><pre><code>function memoize(func) &#123;  var memoized = function() &#123;    var args = arguments,        key = args[0] || &#39;cache&#39;,        cache = memoized.cache;    if (Object.keys(cache).indexOf(key.toString()) &gt; -1) &#123;      return cache[key];    &#125;    var result = func.apply(this, args);    memoized.cache[key] = result || cache;    return result;  &#125;;  memoized.cache = new Object();  return memoized;&#125;// test codevar userId = 1function getUserId() &#123;  userId ++  return userId&#125;;var meGetuserId = memoize(getUserId)console.log(meGetuserId()) // 2console.log(meGetuserId()) // 2console.log(meGetuserId()) // 2</code></pre><h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><ol start="4"><li>输入一个数字, 交换两位数字, 最多交换一次, 输出可以得到的最大的数字; 如输入: 1234 交换 1,4后, 得到4231;</li></ol><pre><code>var maximumSwap = function (num) &#123;  var numStr = num.toString();  for (var i = 0; i &lt; numStr.length; i++) &#123;    var nbr = numStr[i];    var index = i;    for (var x = numStr.length - 1; x &gt; i; x--) &#123;      if (numStr[x] &gt; nbr) &#123;        nbr = numStr[x];        index = x;        console.log(&#39;待交换 nbr&#39;, nbr)      &#125;    &#125;    if (nbr != numStr[i]) &#123;      var arr = numStr.split(&#39;&#39;);      var tmp = arr[i];      arr[i] = arr[index];      arr[index] = tmp;      console.log(&#39;交换后数&#39;, parseInt(arr.join(&#39;&#39;)))      return parseInt(arr.join(&#39;&#39;));    &#125;  &#125;  return num;&#125;;// test codeconsole.log(maximumSwap(5987)) // 9587</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020年中房价分析，预测</title>
      <link href="/2020-nian-zhong-fang-jie-fen-xi-yu-ce/"/>
      <url>/2020-nian-zhong-fang-jie-fen-xi-yu-ce/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>19年底写过一篇房价分析的文章，如今这非比寻常的半年过去了，是时候写一篇新的文章再分析一波了。</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ol><li><p>外部风险</p><p>1.1 全球性金融危机<br>1.2 金融危机给国内经济带来的影响</p></li><li><p>国内经济的韧性</p></li><li><p>政策预测</p><p>3.1 房产税时间点<br>3.2 其他金融工具</p></li><li><p>总结</p></li></ol><h4 id="全球性金融危机"><a href="#全球性金融危机" class="headerlink" title="全球性金融危机"></a>全球性金融危机</h4><p>这个章节有两个问题</p><blockquote><ol><li>是否会发生全球性金融危机</li><li>危机会到什么程度，会对我们的经济造成多大影响</li></ol></blockquote><p>个人认为第一个问题可以略过，危机不是是否会发生，而是已经发生，正在发生。之所以大家现在还无感，美股又重新涨回去,这完全是一种回光返照的现象。美国开启无限量 QE 这个行为是绝对会有严重后果的。</p><p>现在的情况是，08 年之后，全球经济开启量化宽松把当时的损害降到最小，但造成的后果是全球经济长期处于滞胀状态。问题最严重的当属日本，长期大力印钞但是物价和经济就是上不去。原因是金融离不开基础，没有实体的支撑民众信心不足，消费不足，怎么刺激都没用。欧洲其次，和日本一样老龄化问题严重，不同于日本引入了一些移民，且资本更加老牌一些，面对中国崛起被蚕食得部分更少一些，两方面加起来总体面子上好看一些。但实际内里都很虚，欧盟内部问题积累严重，希腊那次还远没有真正爆发出来。08年金融危机是美国引发的，结果是通过印钞让全世界为其买单，欧洲、日本现在的虚，很大一部分原因也都是这一波造成的贻害。并且美国自己也虚，08年之后产业反而更加空心化，国内贫富分化等社会问题愈加严重。</p><p>总之就是08年危机之后，人类并未爆发新的产业革命、技术革命，经济成长除了中国以外基本都是帐面上的虚数。实际是危机造成的影响根本没有去化，甚至更加严重，只是靠新兴国家的发展通过剪羊毛的方式获得了不少输血，仅维持表面的繁荣。</p><h4 id="金融危机给国内经济带来的影响"><a href="#金融危机给国内经济带来的影响" class="headerlink" title="金融危机给国内经济带来的影响"></a>金融危机给国内经济带来的影响</h4><p>第二个问题，危机会到什么程度？这个问题无法定量分析，且听在下高谈阔论吹一波。首先此次的经济危机会和历史上以往的经济危机大不一样。以往的经济危机基本两种形式。工业时代之前只有通货膨胀形式的金融危机。工业时代之后基本上是产能过剩之后迫使政府超发货币进而通货膨胀，两样并发。</p><p>而这次的危机是由全球疫情引发，迫使美国超发货币引起通货膨胀之后导致经济危机。</p><p>而这次的危机会造成怎样的影响，主要要看我国 ZF 的应对方式，要不要跟着美国一起放水。如果跟着一起放，因为我们对美国是贸易顺差，那么本国国民就要相对美国国民成倍的承受通胀压力。如果不跟着放人民币将面对巨大的升值压力。虽然从理论上讲，因为金融的不开放外资很难自由兑换。总之升值的压力肯定会有，升值之后又会降低自己出口产品的竞争力，短时间内会对经济造成重创。</p><p>左右为难，我目前的观察,我国 ZF 是跟着放一点，但是幅度很小很谨慎。我觉得是央妈觉得形势远没有到最困难的时候，最后的武器要留着最后用。</p><p>按照现在情况推演下去，美国会因为疫情和国内其他矛盾集体爆发导致社会运转出现重大危机，进而导致美元信用大幅振动，全球贸易可能因为一般等价物的波动受到巨大影响。届时人民币必将面对巨大的升值压力，而此时正是央妈开闸大放水的最好时期。虽然对外贸易会受到巨大影响，但是跟夺取一般等价物这个蓝星至宝相比，简直不值一提。哪怕只是夺取了部分。舰到用时方恨少，多两条 003 形势简直不是小好，是大好。可惜，可惜。</p><p>上面是往好了想，往坏了想，全球其他国家会认为美元都不靠谱的情况下我没有理由认为人民币更靠谱。全球重回金本位，金价暴涨，这种暴涨可能是十倍百倍级别的。迫使各国银行合作建立起以金本位为准的外汇结算机制（毅种循环）。全球经济进入长期滞胀的大萧条时代。除了黄金和食物任何东西都不会涨价。粮食不能自给的国家必将爆发饥荒战争不可避免，人类文明摇摇欲坠。</p><p>至于这两种情况下房价会怎样，我想已无须多言。</p><h3 id="国内经济的韧性"><a href="#国内经济的韧性" class="headerlink" title="国内经济的韧性"></a>国内经济的韧性</h3><p>OK，让我们先蒙上双眼，假装全球性的经济危机不会发生。假装新冠的影响从下半年开始会慢慢减弱，假装美国新印的钞票不会产生多大影响，假装世界各国的经济都会渐渐恢复，全球贸易也会渐渐恢复。只保留一个条件即因为新冠的影响世界贸易不可能回到新冠前的水准。</p><p>首先看下出口贸易占我国经济的比重。<a href="http://www.mofcom.gov.cn/article/ae/sjjd/202001/20200102930414.shtml">商务部的数据是 19.6%</a>,<a href="https://data.worldbank.org.cn/indicator/NE.EXP.GNFS.ZS?locations=CN">世界银行的数据是 18.4%</a>。假设由新冠影响今年的出口贸易会减少 20% （根据前几个月数据预估）。</p><p>商务部的数据是外贸带动了 1.9 亿人就业，做个简单的数学题，少 20% 意味着 3800w 人失业。连带着第三产业的消费娱乐方面的减少，我们的失业人数是个绝对不能统计的量级。</p><p>这么多人失业房价必跌啊！其实吧，说真的，咋说呢，没啥影响。为啥，资本主义里面有消费者，有劳动力，对于房子来说这部分失业的人原来是劳动力，不是消费者，现在都不是了。仅此而已 over。顶多也就是对三四五线城市的房市有些影响。我举个不恰当的例子，一个餐馆倒闭了，总共一个老板15个员工，你觉得这个城市少了几个购房者？老板通过贷款又买了两套，喜+1,有没有。</p><p>现在的情况是因为处于特殊时期，正常的经济增长对应房价增长的逻辑已经不存在了。世界大放水的前提下，只要不发生经济危机，房价没有跌的理由。</p><p>所以本节讨论的问题点是，外贸下降 20%，以及国内自身经济受到新冠冲击的情况下，会不会发生经济危机。</p><p>个人认为完全不会。只要不发生上一节提到的最坏情况，其他问题在我国基本都不是问题。ZF 还有太多的手段没用上。到目前为止也就金融系统向实体让利 1.5 万亿罢了。既没有 08 年的 4w 亿，也没有 15 16 年的放松限购限贷降低利率。就目前的情况正如中央所说稳中向好。事实如此。</p><h3 id="政策预测"><a href="#政策预测" class="headerlink" title="政策预测"></a>政策预测</h3><p>如果经济不崩的情况下，国内的房价基本就取决于政策。我想这个观点应该没有几个人会反对。</p><p>那么预测房价这个命题大部分时候也就是在预测政策。我在<a href="https://blog.duandiwang.com/2019/11/14/2019-fang-jie-fen-xi/">2019房价分析，未来房价预测</a>一文中通篇没提政策，但是实际上是已经默认了 ZF 是希望抑制房价的。个人认为在 19 年及之前贸易战的环境下，房价的横盘或阴跌是最有利于整个国民经济的选项。所以我在 19 年底做出了那样的预测。</p><p>那么现在环境下，房价怎样的走势是最利于整个国民经济的呢？</p><p>当然还是横盘或阴跌。横盘或阴跌，减轻居民负担，为增加消费提供空间。尤其是在外贸不振的情况下，内需更显重要。降低年轻人的负担，提高生育率其实也是当务之急。唯一的问题就是地方财政。这个问题，我似乎已经看到了解决方法，就是加大土地供应，地价卖不高就多卖几块。正好加紧时间出清，出完了正好推房产税。届时地方财政怎么从卖地转移到房产税收将是一个重大的历史关头。这个话题留待以后再聊。</p><p>现在我们已经有了两个基本条件一是将来大概率需要放水，二是要严防房地产暴涨。暴涨不仅会在短期内吹大泡沫造成完全不可收拾的局面，更会吸走放出来的水，严重滞后经济恢复的时间。</p><p>其实这个目标中央已经在新闻里面说的非常清楚了，六保六稳，总结下来就一条稳房价。房价稳通通稳，房价保全部保。</p><h4 id="房产税时间点"><a href="#房产税时间点" class="headerlink" title="房产税时间点"></a>房产税时间点</h4><p>个人认为大致时间应当是可以推断出来的。即二三四线城市的地方财政无法再以卖地维持之时。</p><img src="/2020-nian-zhong-fang-jie-fen-xi-yu-ce/china-land-sell.png" class=""><p>上表是我国历年卖地总收入，须知土地是有限资源，总有卖完的一天，面对现在天量的卖地收入，将来应该拿什么来填呢？很明显答案只有一个。</p><p>这里以我比较了解的南京来举个例子说明。目前南京长住人口 850w+ 流动人口 400w+，我斗胆估计一下南京未来 50 年的总人口峰值会在 1600w+ 左右。也就是说距离峰值还有 350w 的增长空间。目前南京每年大约成交 7w 套新房。按三口之家算可以满足 21w 新增人口。排除其他所有因素，南京的住房最多还有 15 年时间就将达到完全饱和。</p><p>拿发达国家的经验来看，有 1/3 的家庭是租房的，因为房产税和租售同权的原因。我们未来肯定是要走相同的路的。这种情况下还会挤出相当一部分的空置住房，再加上人口的自然死亡消减。即使是南京这样的新一线粗略估计最多 10 年也必将饱和。</p><p>继续思考，分税制是全国统一的，假设房产税也是。南京还能撑 10 年，其他的二三四线城市呢？很多城市人口流入都成问题。再次可惜我仍然查不到太多可信的数据。大家凭自身感觉吧。就目前的情况来看，四线及以下的城市别说增长了可能维持都是问题。所以中央有意对农村进行改造，收拢原来分散居住的农民，集中建设住房。常看新闻联播的人应该听过相关新闻。这其中不乏为四线以下城市提供新增人口的想法。</p><p>我在之前的文章中就提到 5 年之内必收房产税，就是基于以上的思考。卖地收入无法负担地方财政之时，房产税必须上马，这是不以人的意志为转移的。</p><h4 id="其他金融工具"><a href="#其他金融工具" class="headerlink" title="其他金融工具"></a>其他金融工具</h4><p>中国股市长久以来无法崛起发挥其应有的金融工具作用，最主要的原因不是国家的监管不利，或是房地产的吸水。而是一个更加简单的原因，在坐的都是垃圾。</p><p>美国公司要想拉升股价都是靠分红，投资者获得收益才看好你，投钱给你（买你的股票）。中国各种骚操作就是没这一项，真是奇葩。</p><p>为何如此，就是因为入场要求卡的太严，那些个变态的入场要求，完全都是在扯淡。在中国要是有家公司真的能达到三年稳定业绩利润增长，它还用得着上市去筹钱！？估计天使和风投早就把门槛都踏烂了。</p><p>注册制能不能改变这个现状我不知道，但至少这是中央在往这个方向努力的表现。如果将来股市或债市或其他金融工具能够真正起到金融工具的作用，那么房子也将真正褪去它的金融属性变成纯粹的房子，纯粹的消费品。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 19 年底的时候我认为房价的拐点已经到来，在疫情发生的时候我确定房价的拐点已经到来。直到美国开启了无限量 QE 。未来五年在大水漫灌的前提下，只要不发生重大经济崩溃，房价已不可能再下跌。</p><p>而五年之后土地财政走到尽头，房产税时代开启之后。房价的泡沫必将被挤出。最后再分析一下一套房子的合理价值应该是多少。</p><p>从南京某小区采样举例 165w 的房子租金 3000，租售比 46。按照国际上合理的租售比 30 来计算，合理的价格应在 108w。5 年后假设房产税出台价值回归合理区间如果租金按照每年 5% 的比率上涨，该房的价值应在 137w。这是租售比为 46 的房子的情况，损失为 17%。而租售比为 60 的房子房产税出台后的损失在 38% 左右。</p><p>以上，在下之所以，长时间关注房地产，主要是因为自己有改善的需求。写相关文章也是为自己买房理清思路。这里与大家分享交流，谢谢各位的点赞转发，但若按我的思路投资失败，在下概不负责，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共产主义革命的浪潮必将再次席卷世界</title>
      <link href="/gong-chan-zhu-yi-ge-ming-de-lang-chao-bi-jiang-zai-ci-xi-juan-shi-jie/"/>
      <url>/gong-chan-zhu-yi-ge-ming-de-lang-chao-bi-jiang-zai-ci-xi-juan-shi-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。全世界无产者，联合起来！<br> <p style="text-align: right">—— 共产党宣言</p></p></blockquote><p>当今世界有的国家剥夺了人民各种自由，集会自由，言论自由，婚姻自由，甚至玩个游戏的自由都不放过。</p><p>当今世界有的国家给予人民各种自由，自由的病死，自由的枪战，自由的被警察杀害。</p><p>是制度的不同，主义的不同造成了这样的差别吗？不，恰恰是相同的制度，相同的主义造成了相同的灾难。</p><p>资本主义的原生缺陷：</p><ol><li>人与人的关系被金钱（资本主导的生产关系）定义。</li><li>产能过剩必然造成周期性的金融危机。</li><li>向帝国主义不可逆的进发，导致的贫富分化阶级矛盾。</li></ol><p>上述的问题都可以在这些原生缺陷中找到答案，问题的表象不同只是来自于，社会发展的阶段不同以及少量具体国情的差别。</p><p>两国精英忽悠无产阶级的口吻都出奇的一致，国家太大无法施行北欧模式。</p><p>我有个更靠谱的理由，人的劣根性。我就是想住在几千万的豪宅里面，请一票菲佣，饭来张口衣来伸手，并且我的子孙后代都要这样。</p><p>错了吗？到底谁错了？</p><p>我不知道，我可以预见的是。太阳底下没有新鲜事，历史必将重演。</p><p>当巨龙肆虐蹂躏世界，屠龙的勇士必将出现。共产主义革命的浪潮必将再次席卷世界！</p><p>之后勇士变作巨龙，继续今天的故事。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>肖氏毒奶</title>
      <link href="/xiao-shi-du-nai/"/>
      <url>/xiao-shi-du-nai/</url>
      
        <content type="html"><![CDATA[<p>在这里把过往和今后的预言整理下，也算存档留证。</p><h3 id="14年预言"><a href="#14年预言" class="headerlink" title="14年预言"></a>14年预言</h3><p>农民土地允许上市交易（验证部分）</p><h3 id="15年预言"><a href="#15年预言" class="headerlink" title="15年预言"></a>15年预言</h3><p>16年房市大涨（验证）</p><h3 id="18年预言"><a href="#18年预言" class="headerlink" title="18年预言"></a>18年预言</h3><p>19年房市横盘或下跌（自行体会）</p><h3 id="19年预言"><a href="#19年预言" class="headerlink" title="19年预言"></a>19年预言</h3><p>20年房市横盘或下跌（待验证）</p><h3 id="2020年3月2日"><a href="#2020年3月2日" class="headerlink" title="2020年3月2日"></a>2020年3月2日</h3><p>美股小规模反弹之后持续下跌，2020年引发美国乃至世界金融危机。</p><p>第三次。。（这条我先吃了）</p><p>房产税五年内出台</p><p>中国房市拐点已到，具体要看房产税落实时间点。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N1小钢炮固件使用docker-ui安装openwrt</title>
      <link href="/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/"/>
      <url>/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-ui-安装及设置"><a href="#Docker-ui-安装及设置" class="headerlink" title="Docker-ui 安装及设置"></a>Docker-ui 安装及设置</h2><p>进入N1小钢炮管理后台，点击 System 选项，之后再点击 Startup，在右侧往下拖，找到 Docker 的对应进程选项 /etc/init.d/S60dockerd，把 NO 点为 YES 启用 Docker，再点击左边的 start，之后点击下面的 SAVE 保存</p><p>点击Apps-Other-Docker Setting-install Docker UI （没安装时默认为黄色，下图为已经安装完成后的显示）</p><img src="/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/docker-install.webp" class=""><font size=5><strong>特别注意：这步操作没有在没有科学上网的情况下可能无法顺利完成</strong></font><p>之后重启 N1</p><h2 id="Openwrt-镜像容器安装步骤"><a href="#Openwrt-镜像容器安装步骤" class="headerlink" title="Openwrt 镜像容器安装步骤"></a>Openwrt 镜像容器安装步骤</h2><ol><li>通过 ssh 连接 N1</li><li>输入命令拉取OpenWrt镜像 <code>docker pull kanshudj/n1-openwrtgateway:r9</code> 此步同样建议使用科学上网环境</li><li>运行：<code>ip link set eth0 promisc on</code></li><li>运行：<code>docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 macnet</code><br>（将第三个单独的1改为你主路由的网关地址，即你登录你主路由后台的IP地址第三位数字）<blockquote><p>这步是在 docker 环境中创建一个名为 macnet 的网卡</p></blockquote></li><li>运行：<code>docker run --restart always -d --network macnet --privileged kanshudj/n1-openwrtgateway:r9 /sbin/init</code></li><li>进入 Docker 管理界面，点击 Local，再点击 Containers</li></ol><img src="/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/docker-init-step-1.webp" class=""><ol start="7"><li>找到自己刚拉取完成的 OpenWrt 镜像，选择第四个命令行工具</li></ol><img src="/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/docker-init-step-2.webp" class=""><ol start="8"><li>点击Connect</li></ol><img src="/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/docker-init-step-3.webp" class=""><ol start="9"><li>输入 <code>vi /etc/config/network</code></li></ol><img src="/n1-xiao-gang-pao-gu-jian-shi-yong-docker-ui-an-zhuang-openwrt/docker-init-step-4.webp" class=""><ol start="10"><li><p>找到3处包含192.168.X.X的地方，输入i进入编辑，同样将第三个数字的位置改为你主路由的网段，在此处我的主路由为123，所以我将三处都改为123。当编辑完成后，按一次键盘左上角Esc键，之后输入：wq并且回车。（英文冒号+wq）</p></li><li><p>设置 OpenWrt 的初始密码命令为 <code>passwd</code> 还有可能为 <code>password</code> 或 <code>mount_root</code>。输入正确之后会提示你输入正确明码。 </p></li><li><p>重启N1</p></li></ol><p>之后就可以通过你设置的 Openwrt 地址进入管理界面了（管理地址为上如3红框中的第一个），到这里我们旁路由OpenWrt就算全部设置完成了</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.iyyxz.com/%E6%96%90%E8%AE%AFn1%E5%B0%8F%E9%92%A2%E7%82%AEdocker%E5%AE%89%E8%A3%85openwrt-lede%E5%81%9A%E6%97%81%E8%B7%AF%E7%94%B1%E7%A8%B3%E5%AE%9A%E5%8E%BB%E5%B9%BF%E5%91%8A%E7%A7%91%E5%AD%A6%E5%8A%9F/">斐讯N1小钢炮Docker安装OpenWrt/LEDE做旁路由稳定去广告+科学功能</a></p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>我自己进行相关操作时遇到了两个坑，故把前人的操作步骤再完善一下，希望能让后来者少走弯路。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗老师语录</title>
      <link href="/luo-lao-shi-yu-lu/"/>
      <url>/luo-lao-shi-yu-lu/</url>
      
        <content type="html"><![CDATA[<p>1.“这几天又买了十几台安卓手机试玩儿，包括三星摩托罗拉索尼HTC小米魅族的热门机型（大都是我们前期的安卓定制版将要支持的机型）……怎么说呢？只能说“越看越放心”吧。还是那句话，这个行业只有一个聪明人，可他已经死了，剩下的是一群选错了行业、即将再次被虐杀的倒霉蛋……”——罗永浩</p><p>2.“把车停到公司楼下， 我摸了摸，给同事买的几盒炒面依然滚烫。去时的大雪完全停了，我打开天窗，车顶残留的雪落了我一头，能看到很多星星，凉凉的空气好得不像话，喇叭里的音乐也从重金属变成了钢琴曲…突然我就伤感起来了：你只是勤奋工作，努力做好自己，结果很多你的同行就要倒闭了…生命真残酷啊。”——罗永浩</p><p>3.“自打我公布要做手机以来，已经有无数朋友给我“支招“了，大部分主意集中在如何“填补市场空白”……唉，我要做的是最大最热最帅，竞争最残酷激烈的那块核心地带啊，“填补市场空白“还是留给那些没有雄心壮志，只想赚点儿小钱的企业吧。”——罗永浩</p><p>4.“我们做两到三代产品之后，灭掉苹果是没有问题，只要我们做成功了两款产品，第三款产品一定是去北美卖的，我不满足在中国做一个企业，没什么大意思”——罗永浩</p><p>5.”托马斯·骆说的好，不过还是保守了。用户体验、审美、营销推广、恋物、完美主义倾向这五项我都不输乔布斯，只差了一个现实扭曲场，但我人格力量远胜，加上这个行业全是土鳖和笨蛋，不骄傲地说，胜算很大。”——罗永浩</p><p>6.”卖出去的产品要做好售后服务，这是做企业的基本原则，但卖东西的时候我们不会刻意讨好或迎合各种脑子不好的消费者，好东西牛逼哄哄的摆在那里，你爱买不买。”——罗永浩</p><p>7.”摩托罗拉南京研发中心有四百多人？！难怪这企业要完蛋。”——罗永浩</p><p>8.”风投的那帮孙子只要有钱赚就会扑上来，不用惯着他们，否则你去舔他们也是白舔。”——罗永浩</p><p>9.”当然，牛逼吹得非常保守，比如我就不觉得我们的第一代硬件产品从工业设计和工艺上能全面超过iPhone。” ——罗永浩</p><p>10.“是，所以我也没打算一下就灭了苹果，先是三星、LG、索尼、HTC、OPPO、魅族…”——罗永浩</p><p>11.”嗯，觉得自己可以接乔布斯班的笨蛋很多，我看好的只有这一个 ，苹果之所以成功，除商业模式创新之外，最重要的是乔布斯不仅是顶级艺术家，还拥有光芒万丈的商业智慧，于是苹果成为独一无二的苹果。国内的@罗永浩可爱多 有艺术家的气质，也有非凡的商业智慧，个人品牌传播力也非常强悍，或许会成为中国的乔布斯，也未尝不可能。”——罗永浩</p><p>12.”虽然只想了几星期，但我们在软硬件结合改善用户体验方面的创新方案足以使我们将来单靠卖专利(已在准备专利申请所需的材料了)都能维持…可惜没碰到有眼光、大手笔的风投资本家（其实也不需要很大手笔，一千多万美元而已[挤眼]），逼得我们只好先做rom后做硬件…好饭不怕晚，只是苦了望眼欲穿的人民。”——罗永浩</p><p>13.”放心，手机进展很顺利，胜利的结局完全没有悬念，如果不是热爱做这个，早就受不了这么不刺激的创业了。”——罗永浩</p><p>14.“昨晚看完胡德夫回来加班，本来四点能完的工作折腾到了八点，大部分进展顺利，但个别难题到下班为止还没解决，希望今天下午搞定…又要忍不住说实话了：我们的rom就算打50%折扣也是安卓系统的第一。谷歌看了保证当场抽搐，接下来要收购可就讨厌了，我肯定是不卖的，但他们一生气不开源了就有点小麻烦。”——罗永浩</p><p>15.“我们很有可能成为上千亿美元市值的企业，而我之前总是低调地用人民币去估它。”——罗永浩</p><p>16.“你就当这是哥的幻觉吧：我已经想清楚了，对这个世界来说，乔布斯的稀缺性在于他骨子里是一个文青，但奇迹般地有兴趣和能力去运营一个企业。这两种品质发生在同一个人身上的概率，应该比一个人被雷劈中三次的概率高不了多少。但刚好在他去世前后，在神秘古老的东方，有一个……你懂的”——罗永浩</p><p>17.“国内最好？我知道你没有恶意，但这确实小瞧我们了。”——罗永浩</p><p>18.“是，单从美观的角度，智能手机正面的工业设计能拼的已经不多了，接下来要拼的是操作系统的UI，这方面除了苹果，没有一家是及格的。单以我们简洁优美得一塌糊涂的UI，加上我的传播推广能力，就足以撑起一个畅销手机产品了（想想当年的刀锋和巧克力），何况我们在用户体验方面还有很多天才的创新…”——罗永浩</p><p>19.“等了一个多月[可怜]，今天终于搞定了我们的CTO[呵呵]，一个伟大的公司就要不可避免地诞生了[酷]。手机行业唯一的聪明人死后，不是我选择了这个行业，是命运选中了我。刚才在卫生间洗脸，发现额头上隐隐有一个“王”字…..好吧，我承认它的学名是抬头纹，但抬头纹里为什么有一个竖呢？[吃惊] 待续…..”——罗永浩</p><p>20.“今天大家没太多事儿，还不到半夜十二点，就早早下班了。我一个人看着平庸的空办公室（租下来后没顾上重新装修），随手拍了张照片……后代的人们看到这张照片可能很难相信，一个改变世界的传奇科技公司竟然不是诞生在一个屌屌的车库，而是在这么一个除了异常整洁，哪儿都平凡的不能再平凡的写字间里。”——罗永浩</p><p>21.“有百分之五十就该去创业…何况我这次是百分之百。”——罗永浩</p><p>22.【最开心的是，在这个妖怪国家，我做营销都不用使什么手段，只要保持本色，猛说实话，就足以让无数的二逼们围着破口大骂、暴跳如雷、疯狂转发还附送犀利评论：“我倒要好好看看罗永浩你这个傻逼能弄出什么样的产品来！”】——罗永浩</p><p>23.“即便我们一时不能全面超过iPhone，也会让玩腻了iPhone又受不了其他手机（几乎是一片烂货的汪洋大海）的用户高高兴兴买单。”——罗永浩</p><p>24.【我和闯爷坐进车里，我劝他系上安全带，“你能想象咱俩要是出了车祸，还没系安全带，人类的智能手机事业会被耽误成什么样吗？” 闯爷认真想了想，“至少几十年吧。” “不知道”，我说，“反正我是不太敢细想。”】——罗永浩</p><p>25.“安卓这个烂摊子，只能靠我们做出些品质了。”——罗永浩</p><p>26.“才一个多小时就转发一万多了，心里突然有点慌：不知道这些人看了真东西有多好之后会疯狂成什么样子…” ——罗永浩</p><p>27.“我们初期产能不足的话，索性预收全款排队发货，这样资金周转就不是问题，你们也不用网上抢，敢预付全款先买到的人都是信任我们的，所以初期口碑一定更好，交钱后反悔的及时退款就是了……初步设想是这样。”——罗永浩</p><p>28.“大家都是做手机的，有些天快亮了，有些太阳已经下山了，还有些奄奄一息反正也是没救了的，给它们一锤子，也算死得安乐了。”——罗永浩</p><p>29.“我们不卖低端机，盯也盯的是中产阶级的钱包。”——罗永浩</p><p>30.“我认为智能手机这个领域里全是笨蛋（乔去世后），我的胜算简直不能更大了。”——罗永浩</p><p>31.“发现国产手机厂商现在都喜欢打电梯广告，这半年在电梯里陆续看了小米、魅族、oppo 和 nubia 的平面广告，回想起来，好像全都一个样，没有任何特色…… 大家明明是分头做的，但最后看起来都差不多，这也挺不容易的。对了，小米广告的“屌爆了”还是有点特色的：傻。”——罗永浩</p><p>32.“锤子ROM的论坛弄好了，今天晚些时候开放，我看了看其中的一条版规：“欢迎批评一切手机厂商或ROM团队，包括锤子科技，但禁止诽谤中伤任何厂商或团队。另外，盲目支持我们并胡乱辱骂我们竞争对手的用户将被管理员警告，屡劝不改的用户将被永久禁言。” 想起鬼气森森、妖孽横行的魅族论坛，我伤感了…” ——罗永浩</p><p>33.“还有很长的路要走，但肯定已经是很耐看的了”，我回短信说，“我们一定会接过乔老的大旗，用伟大的产品改善人类的生活品质的！” 有那么一会儿，我的眼眶有点红了… 我…我就调整了一下呼吸”——罗永浩</p><p>34.“Ios7按现在的路数走下去，很快就成乡村机了。”——罗永浩</p><p>35.“因为我们在做工方面的苛刻要求，目前产线上的良品率较低，按照我们和富士康的工程师的估计，未来一两周内可以上升至健康合理的正式量产水平。其实，现在我们产线上不能通过质检的大多数产品，做工也要比绝大多数手机厂商的产品好很多。目前为止，我们送测的工程机在做工方面几乎得到了所有媒体的一致好评，但和工程机一样水准的做工，在我们的产线上仍然是不良品。下周我们会从这些未通过质检的产品中拿出30台在新浪微博上做抽奖活动（仅限抽奖活动开始前已下单的客户参加），让大家看看做到了什么样的精细程度后，在我们的质检标准上仍然是不合格的。我们只要放松一点点品控标准，就会带来产能上的明显提升，但相信这不是你们希望的结果…即便这真是你们希望的结果，我们也不会这么做。”——罗永浩</p><p>36.“我们的rom完成度还很低，还有段路要走……但走到的那天，你们会知道什么叫洗牌。”——罗永浩</p><p>37.“刚才看了一下安智团队给锤子rom适配小米2的屏幕效果，虽然驱动有问题导致画面动起来的时候会瞬间破碎，但……孙子骗你…小米2装了锤子rom，完全是屌丝瞬间化身国际高富帅（且已富了至少三代）的效果。”——罗永浩</p><p>38.“我们一开始就计划做好几款手机就杀出国门，现在小米又在前面探路国际化，我们简直不能更高兴了。探路需要付出大量时间精力，我们把它省下来用在产品上感觉很幸运。另外，我们的目标用户跟小米重合度不高，如无意外，将来手机产业格局多半是小米通杀低端，锤子通杀高端，其他厂商…唉呀，真的不敢想”——罗永浩</p><p>39.“尊重别人的劳动成果”这个二x理论最初是从哪里来的？尊重别人的劳动态度、精神、追求等等可以理解，劳动成果为什么一定要尊重？劳动成果好就是好，翔就是翔，不能因为你消化得异常努力，消化得格外孜孜，就要尊重你吃了牛肉干之后艰辛排出的干燥翔。”——罗永浩</p><p>40.“我死也不会说的，我现在是成熟的企业家，我们这个二逼圈子，成熟的标志是不说实话。”——罗永浩</p><p>41.“如果我们上市后我说话少了，一定是因为忙，而不是为了稳定股价。”——罗永浩</p><p>42.“今天听到业界大佬说，老罗他们做得再差，也能做到一到两个魅族那么大。我觉得这跟骂人差不多，一些同事却感到很欣慰……”——罗永浩</p><p>43.“所有的行业都是被楞头楞脑杀进来的“外行”颠覆的，“内行”满脑子都是维持现状。”——罗永浩</p><p>44.“锤子明明还在路上，为什么你们总是把我和这些已经功成名就的科技大佬们相提并论？你们这样会害了一个年轻的企业家的！”——罗永浩</p><p>45.“我埋头做产品的时候和埋头吹牛逼的时候全都是真诚无比的。”——罗永浩</p><p>46.“我会努力的，把锤子做好了将来收购不可避免地走向衰落的苹果并复兴它是我余生义不容辞的责任。而且我也意识到，只有这样，才能让提姆库克和强纳肾爱抚明白，谁才是从精神和方法论上都真正继承了乔布斯衣钵的唯一传人。”——罗永浩</p><p>47.“从工业设计的角度，锤子黑色版可能是史上最接近完美的黑色版智能手机。”——罗永浩</p><p>48.“在公司楼下坐着晒了会儿太阳，想象了一下退休后的生活，好像还挺让人向往的，公司做到上千亿市值，我们的产品成了街机，我就可能退休了。”——罗永浩</p><p>49.“还剩53天了，每天数着日子过，看着手里一代代更新的工程机日趋完善，百感交集，真希望一觉醒来就是发布会那一天了。大卖和赚钱，从一开始就是没什么悬念的事，不急，我只是希望尽早让那些顶着傻逼们的冷嘲热讽坚持信任我们的人知道…我不会让你们失望的。怀抱着2014年年度最佳手机…屌屌地睡了…晚安。”——罗永浩</p><p>50.“除非山穷水尽，否则我们不会考虑拿互联网大佬的投资，其中的一家我们嫌丢人，另外两家迟早血雨腥风地打起来，我们不想过早站队…何况如果我们发展的顺利，将来谁站谁的队还不好说”——罗永浩</p><p>51.“最重要的还是最终的产品，产品做得好，前面的争议都是营销传奇；产品砸了，前面我温良恭俭让也只是温良恭俭让的傻逼。”——罗永浩</p><p>52.“我们眼里的对手只有苹果，其他的就算有些小亮点，也不足以成为我们的……你懂的。”——罗永浩</p><p>53.【这么客观、靠谱、专业、好看的评测，在魅族的脑残粉看来，也是“王自如竟敢黑我大魅族！”】-——罗永浩</p><p>54.”我们不搞宏大叙事，只让用户高兴得眼泪鼻涕横流，大小便失禁。”——罗永浩</p><p>55.”我是一步一个脚印的那种踏实人,不会吹离谱的牛”——罗永浩</p><p>56.“从来没有一个如此美好的产品和品牌，遭遇到过如此大规模的误解、污蔑和诽谤。”——罗永浩</p><p>59.”下次不可以对友司用恶意引号、挤眼、做鬼脸，你毕竟是官方微博……虽然他们确实挺傻的。” ——罗永浩</p><p>60.”我渐渐想明白雷军作为新兴手机企业老大最近为什么这么失态了：别看国内这么多手机企业，全都是做不出差异化产品的，巨头们赚的都是苦逼钱，没多少利润。目前国内能做出差异化的只有小米和魅族，但魅族不懂营销，软件二流，硬件虽好，整个体验远不如小米。所以我们出道前雷军就没紧张过谁……你懂的。”——罗永浩</p><p>61.”谬赞了，做工要超过 iPhone 还需要一点点时间，但“目前拆过用料最良心的一部手机”基本上应该是靠谱的。”——罗永浩</p><p>62.”体面的企业不会用“x999”的方式拿消费者当傻x，3000就痛痛快快3000，2999太猥琐了。” ——罗永浩</p><p>63.”并且作为一个体面的企业家，克制地隐藏了脏字” ——罗永浩</p><p>64.”不会，我找来的三个国内UI设计师，都认为自己可以灭掉苹果，只是需要一点点时间，比如半年。”——罗永浩</p><p>65.”到现在为止，苹果、三星、LG、索尼、HTC、摩托罗拉、诺基亚以及“中华酷联海”中的中兴、华为、联想，还有小米，都已经来信索取门票要求参加锤子ROM（”Smartisan OS”）发布会了。看来酷派、海信、魅族这几个无知无畏的厂商还不知道等着他们的悲惨命运是什么”——罗永浩</p><p>66.”哦，是吗？魅族真的很烂！三星、索尼、诺基亚、LG、摩托罗拉、HTC有些硬件还不错，软件一律很烂。只有苹果值得我们学习，但超越它也只是迟早的事。”——罗永浩</p><p>67.”三星、诺基亚、摩托罗拉都不是我眼里的对手，何况其中还有一个已变卖，一个快倒闭了。如果乔布斯还活着，我不敢说很有把握，但乔布斯死了之后，赶超苹果也只是迟早的事。希望我们崛起前苹果不要走下坡路，免得赢了也没什么意思。”——罗永浩</p><p>68:“说实话，看着一群做电饭锅出身的家电厂商，不会做用户体验，只能笨笨地拼硬件……在这样的市场，我们稍一发力，就鹤立鸡群了。” ——罗永浩</p><p>69.“试玩儿的这些手机中，个别产品的工业设计本来已经做到大概80分了(如果把苹果的Iphone 4作为99分的标准)，但总有一个非常二逼的细节把整个分数大幅度拉低，很可能是这些企业并不缺优秀的工业设计人员，但决策者的愚蠢导致了这个结果……”——罗永浩</p><p>70.“苹果和三星瓜分了全球智能手机市场份额的百分之九十多，剩下一群大傻</p><p>屄，号称电子巨头在那抢饼干渣，你抢的饼干渣脸嘴角都没抹，怎么好好意思说</p><p>别人是业外人士呢？在我眼里，他们甚至都不是我对手，就一臭傻屄，然后你得</p><p>意洋洋地说你是业内我是业外，业你妈屄啊业”</p><p>71.“MX采用了前黑后白的设计，看起来特别业余，想那些二逼产品允许用户“随心换彩壳”后的恶劣结果。”——罗永浩</p><p>72.”水粉色系就是臭土鳖喜欢的颜色，你什么时候见过有文化的人喜欢粉色？”——罗永浩</p><p>73.“香槟金”就是为了抚慰土豪缺乏安全感的心灵诞生的名词，喜欢穿粉衬衫的ross不得不给粉色起个名字叫做“褪色的三文鱼色”。</p><p>75.”不奇怪,穷学生一直都是小米的客户群嘛” —罗永浩</p><ol start="76"><li>锤子科技在2015年夏季发布会上宣布的smartisan公益基金，至今未成立,现在依然是Coming soon状态 网址:Coming soon…坚果发布会筹集的100万元门票收入也神秘失踪。锤子科技经营范围并不包含营业性演出，请问这100万元去哪儿了？一个公众人物在公开场合做出的捐款承诺是不是可以随便食言？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RWBY才是真正的女权主义影片</title>
      <link href="/rwby-cai-shi-zhen-zheng-de-nu-quan-zhu-yi-ying-pian/"/>
      <url>/rwby-cai-shi-zhen-zheng-de-nu-quan-zhu-yi-ying-pian/</url>
      
        <content type="html"><![CDATA[<p>突然想到 RWBY 可以给现在盛行的田园女权们好好上一课，什么才叫他妈的女权！</p><p>随便上几组人物对比</p><p><strong>Salem vs Ozpin</strong> 被爆cèi了几万年的负心男，如今更是当起了鸵鸟连人都见不到了。</p><p><strong>Yang妈 vs 叔叔</strong> 呵呵还用我多说吗？一个整日借酒度日，一个带领族人顽强生存。</p><p><strong>Adam vs Blake</strong> 这个乍看还好，Adam虽然是反派也算有种有型。对比在于失败后的表现，Blake重新站起直面敌人。Adam恼羞成怒，彻底癫狂差了个层次。</p><p>最后</p><p><strong>P姐 和 小强</strong> 尼玛，制作组，还我P姐！</p><p>通过上面几组的对比，请问他们之间的差距在哪？精神意志的强弱，无它。</p><p>同理在其他各种不同的领域中的竞争决定胜败的往往都是意志力的强弱。</p><p>放在现实人类社会中也有很多有价值的例子。一个顶级强大的女性和顶级强大的男性几乎没有区别。同样无视世俗的眼光成就自我。中等强大的女性是最受伤的一个群体他们往往和身边的男性一样强或更强，却受限于自身所在的群体弱而收到不公平的待遇。弱的女性和弱的男性区别同样不大。</p><p>可惜实际情况是中等强大的女性数量太少。但是自然界不管这些，群体的弱同样是弱。</p><p>要想地位就要强大，枪杆子里面出政权，革命不是请客吃饭。自由有价。说的都是一个道理。RWBY这部作品虽然无意，但是却向我们展示了一个女性更强一点的世界会是什么样子——比男人打架好看多了！</p><p>以上纯属瞎侃，请勿严肃和我讨论女权问题，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019房价分析，未来房价预测</title>
      <link href="/2019-fang-jie-fen-xi/"/>
      <url>/2019-fang-jie-fen-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>18年底写过一篇<a href="https://blog.duandiwang.com/2018/11/23/peng-you-gai-mai-fang-liao/">《朋友该卖房了》</a>，没有主动发出来和大家分享。主要是写完之后觉得没有干货，没有调查研究，基本都是以自身感觉为基础进行的推理，说服力不强。虽然这个基础也是来源于我的阅读。</p><p>现在来看去年年底我的预测没有错，今年的房价走势基本是下降趋势。文中也有提到一线城市和二线黄金地段不在讨论范围，事实也基本如此。只是预期中的大降价没有到来，这也是我当时没有发出来的原因，感觉对19年发生大降价的可能性没有太大的把握。</p><p>既然一年又过去了，我觉得有必要来一波真正的干货真正的系统性分析了。不仅是写给朋友们看，当然也是因为自己也身处其中，可以说房价和我们每个人都息息相关。</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ol><li><p>全国性分析</p><p> 1.1 货币<br> 1.2 居民收入<br> 1.3 出生/适龄人口<br> 1.4 GDP总量比值<br> 1.5 全国性总结</p></li><li><p>地区性分析-南京</p><p> 2.1 居民收入、GDP增速<br> 2.2 流入人口<br> 2.3 城市潜力分析<br> 2.4 房价租售比</p></li></ol><p><a id="货币" style="display: none"></a></p><h3 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h3><img src="/2019-fang-jie-fen-xi/RMB-M2.jpg" class=""><p>首先针对这张图真实性表示怀疑。一般性的认知，RMB发行量和对外贸易盈余有很大关系。</p><img src="/2019-fang-jie-fen-xi/china-trade-surplus.jpg" class=""><p>请看这张图，最近五年的贸易盈余。18年19年有明显的下降趋势，但是广义货币（M2）的增速曲线却几乎是完全平缓的。如果说M2曲线也是完全真实的，那我不得不感叹原来猪肉也能当蓄水池。开玩笑，消费品不具备金融属性，这显然是不可能的。</p><p>我相信中央不可能在贸易盈余下降的情况下还搞量化宽松，完全没有可能。而且现实情况是银行已经对地产行业收紧了贷款。我有理由相信M2的增速不可能完全由上图所示，增速较往年应当要缓一些。接下来的分析以这个推论为基准。</p><p>PS：这里补充一个M2增速没有降低的可能性，就是RMB的国际化进程。在对外投资过程中产生了大量广义货币。但是这部分新产生的货币回流速度肯定很缓甚至没有回流，对国内的房价不会有直接影响，这里不考虑这部分因素。</p><h3 id="居民收入"><a href="#居民收入" class="headerlink" title="居民收入"></a>居民收入</h3><img src="/2019-fang-jie-fen-xi/rural&urban-households-disposable-income.jpg" class=""><p>上图为最近几年城乡居民家庭可支配收入的中位数，简单算了一下增长率目前还可以跑赢通胀，但是较早几年有明显下降。</p><p>收入是支撑房价的基石，而且由于最近几年的反腐工作比较有成效。体制内及相关人员的灰色收入也是有很大降幅的，但是这个在表上肯定没有体现。</p><p>所以随着总体收入增速的下降，至少支撑房价高速增长的基本条件已经不存在了。</p><p>其他关于收入的数据：</p><p><a href="https://wenku.baidu.com/view/db9e3f5f84868762cbaed5ba.html">1978-2015中国历年GDP与城镇居民人均可支配收入统计表</a></p><p><a href="http://www.stats.gov.cn/tjsj/zxfb/201901/t20190121_1645791.html">2018年居民收入和消费支出情况</a></p><p>2018年全国居民人均可支配收入28228元</p><h3 id="人口"><a href="#人口" class="headerlink" title="人口"></a>人口</h3><img src="/2019-fang-jie-fen-xi/population.jpg" class=""><p>最好理解的一张图，从1990开始新生人口不说是断崖式下跌情况也基本差不多了。新生儿大潮的最后一波同学明年也将迈入30的门槛，今年不买房明年也该买了，剩下的必然就是掏空6个钱包也买不起的了。</p><p>至于90年之后的情况相信大家也都了解了，放开二胎的时候小抬头了一下，之后就是一路下降，估计下面就是国家开放三四五胎生育率也上不来了。</p><p>也就是说新生人口对房价的推动力，今年不是最后一年那就是明年了。</p><h3 id="宏观数据"><a href="#宏观数据" class="headerlink" title="宏观数据"></a>宏观数据</h3><p>450万亿！中国房产市值超美欧日总和。但是我尝试查了下数据来源，不是来源自任何机构，而是两个名人有提到这个数字一位是潘石屹，一位是经济学家向松祚</p><p>姑且用这个数字列个表格看下GDP和房地产总值的比值</p><img src="/2019-fang-jie-fen-xi/real-estate-gdp.jpg" class="" title="房产GDP各国市值比"><p>就算这个数字有水分，也能看出中国房地产的泡沫不是一点两点，同时我看到2016年的数据是GDP 10.68房地产 43 比值 4.02，也就是说经过2016年底的一波大涨比值是继续扩大的趋势。本来GDP的增长就已经进入减速区间，比值还在继续扩大充分说明2016年底的大涨完全是透支未来的投机行为。</p><p>下面还有两幅图，可以进一步说明我国经济结构目前的畸形情况。</p><img src="/2019-fang-jie-fen-xi/real-estate-stock.jpg" class="" title="房产股票各国市值比"><img src="/2019-fang-jie-fen-xi/real-estate-household.jpg" class="" title="房产家庭资产占比"><h3 id="全国性总结"><a href="#全国性总结" class="headerlink" title="全国性总结"></a>全国性总结</h3><p>我们已经从三个维度分析了房价，不论是收入、人口、还是经济总量，都绝对没有支持房价继续高速增长的理由。人口和经济总量甚至都不足以支持房价继续增长了。至于收入和房价的比值只有放在单个城市看才有意义，我们放到下一阶段讨论。</p><p>至于城市化，有两个先决条件，一是年轻人口的净流入，二是能在城市安家才叫城市化。人口已经分析过90年之后的人口增长大幅下降，可见的未来不会再有大批的年轻人进城的情况发生。你也不可能指望农村40-50岁这个年龄段的突然进城打拼，他们当中可能很大一部分已经拼过又回去了。再上当的可能性不大，身体也不支持了。</p><p>二是在城市安家，现在每年大专本科毕业生800w，其中有多少能留在城市，大家心中自有秤，我觉得不必多说。而且就算这800w都能在城市安家，中国目前地级市293个，你算算一个城市能分到多少。其中的绝大部分当然会被一二线瓜分，所以后面还得单独分析。</p><p>其他迹象，万达全面转型，万科高喊活下去，碧桂园大面积新房出现质量问题。造成这些的原因就是国家银根对房地产的缩紧。这说明中央已经承认泡沫的存在，收紧银根就是为了预防系统性风险（看新闻联播的应该经常听到这个词），防止房地产倒塌时带着银行一起走。</p><p>总结，全国范围看房产价格停止上涨是必然，大概率在未来很长时间内横盘或下降，中小概率全面崩盘。横盘、跌、崩盘这几个选项中到底会落在哪个取决于以下几点，新的技术革命，美国发生金融危机或政治危机，一带一路跨越式进展。如果你认为以上几个事件在未来五年有一个以上必然发生，那么我建议你有钱继续买房。</p><p>但是不管手上有房无房，对我们普通老百姓来说最好的结果就是横盘或小幅阴跌以时间换空间，等待经济发展挤掉泡沫。否则兴百姓苦，亡百姓苦，稳定压倒一切。</p><h2 id="南京地区分析"><a href="#南京地区分析" class="headerlink" title="南京地区分析"></a>南京地区分析</h2><h3 id="居民收入-1"><a href="#居民收入-1" class="headerlink" title="居民收入"></a>居民收入</h3><table><thead><tr><th>年份</th><th>收入</th><th>增长率</th></tr></thead><tbody><tr><td>2018</td><td>59308</td><td>8.75%</td></tr><tr><td>2017</td><td>54538</td><td>9.08%</td></tr><tr><td>2016</td><td>49997</td><td>8.44%</td></tr><tr><td>2015</td><td>46104</td><td>8.31%</td></tr><tr><td>2014</td><td>42568</td></tr></tbody></table><img src="/2019-fang-jie-fen-xi/Nanjing-GDP-growth.jpg" class="" title="南京历年 GDP 增速"><p>2018 南京的 GDP 增速是 9.43%，从过往几年来看 GDP 和收入的增速差距越来越小，不知道是好事坏事。</p><p>再看一下房价的走势</p><table><thead><tr><th>年份</th><th>均价</th><th>增长率</th></tr></thead><tbody><tr><td>2018</td><td>26359</td><td>36.98%</td></tr><tr><td>2017</td><td>19243</td><td>23.49%</td></tr><tr><td>2016</td><td>15583</td><td>12.02%</td></tr><tr><td>2015</td><td>13911</td><td>8.81%</td></tr><tr><td>2014</td><td>12785</td><td>15.89%</td></tr><tr><td>2013</td><td>11032</td><td>-4.42%</td></tr><tr><td>2012</td><td>11542</td><td>4.76%</td></tr><tr><td>2011</td><td>11018</td><td>49.07%</td></tr><tr><td>2010</td><td>7391</td><td>16.38%</td></tr><tr><td>2009</td><td>6351</td><td>14.19%</td></tr><tr><td>2008</td><td>5562</td></tr></tbody></table><p>计算最近10年的平均增长率17.7%远高于 GDP 和居民收入增长率。显然这种状况不可能一直持续下去。</p><p><a href="http://221.226.86.104/_web/_plugs/statTable/statTableForQuery.jsp?statTableCategoryId=5&amp;_p=YXM9MSZ0PTAmcD0xJm09TiY_#">数据来源-政府网站</a></p><h3 id="流入人口"><a href="#流入人口" class="headerlink" title="流入人口"></a>流入人口</h3><p>我个人观点在其他国家流入人口不应成为推高房价的因素，城市扩大之后增长的人口应该消费的也是增长部分的住房。顶多推高核心区域的房价，因为城市扩大之后核心会变得更核心。</p><p>但是我国有几个特殊情况，首先流入的人口携带的不仅是自身的购买力还可能是其家庭的6个钱包的购买力。其二，重点城市的房价不仅有居住属性，还同时具备教育、医疗等其他公共服务价值属性。同时这些附加值导致我国基本不会出现老年人离开其原城市居住地到其他地区养老的情况，进一步减少的人口流出情况。其三，我国没有房产税，城市公共设施建设及维护的费用全部来自新房的土地拍卖出让金。等于是新房购买者同时负担了整个城市旧房及其附属公共设施的维护费用。随着城市的扩大公共设施建设维护费用的增加必然转嫁给新房房价。（PS：只要明白这个第三点，就会知道房产税早晚都要收，深圳的土地出让到期之后的解决先例等于说明政府已经变相承认土地的永久使用权，等于解决了法理问题。如果不收房产税，使用权就真变成所有权了。这里有个逻辑矛盾点，但是是必要矛盾，以后有空再详细讨论。）</p><p>好下面来看看南京的人口流入数据。</p><img src="/2019-fang-jie-fen-xi/nanjing-population-growth.jpg" class="" title="南京历年户籍人口"><p>一年4-5万人的增长最近两年由于政策优化户籍人口增长加快了，但是我从<a href="https://kknews.cc/news/o8g8g5.html">其他渠道</a>有看到外地在宁人口有下降，等于是转化了部分原来的外籍人口取得了户籍人口的增长。</p><p>总体来说南京前十年都没有什么特别出彩的产业升级或爆发。二线的工资一线的房价导致对人才新引力的匮乏，最近两年因为一线城市的生存压力实在太大，对人才有了一定的吸引力，可以看到阿里到南京搞个分部也是看到了南京的人才红利。</p><p>但是随着一带一路中部大开发的进行远期来看人才吸引力完全不及中部，举个例子重庆工资标准和南京差不多，房价却要低很多。（PS:妹子都更漂亮！）</p><h3 id="未来发展潜力"><a href="#未来发展潜力" class="headerlink" title="未来发展潜力"></a>未来发展潜力</h3><p>一个城市的未来发展潜力和诸多因素相关，人才方面上节已经分析由于大环境的原因我并不看好，和中部城市竞争第二梯队的人才能力不足。好在江苏安徽地区的本土人才数量较多，这部分中部城市应当抢不走。</p><p>地理位置，南京的地理位置是经过历史证明的，不管是古代还是近代都是极为重要的。反倒是现在两省省会的定位到没什么出彩的地方。学府还在人文气息也有但总感觉少了点什么，你懂的。总之占着宝地未来发展总不会太差。但是最终究竟是千万，一千五，还是两千就是个值得讨论的问题了。个人认为两省之地一千五百万是绝对的上线，实现这个目标没个二三十年不太可能，近十年能上一千万就是很不错的成绩了。</p><p>另外近些年合肥的发展也挺好，中科大是个奇迹般的学校。往长远来说如果合肥能发展好，一千二三百万可能就是南京的极限了。</p><p>国家政策。说实话除了名字里的京字，以及东部战区指挥部驻地，我就没感觉到南京在其他方面有什么政治优待。再加上几个不咋地的市长，就两字尴尬。现如今，拿的出手的大企业屈指可数，房地产被抹了个光头，互联网具备人才优势，却只能替他人做嫁衣，本土龙头苏氏除了996啥都没学会，什么雨润中央同样是有样学样可能具备中国企业之最强法务团队（误，现在应该是某为了），悲剧。最近好歹混了个国家级开发新区，但也仅仅就是十几个城市中的一个。</p><h3 id="房价租售比"><a href="#房价租售比" class="headerlink" title="房价租售比"></a>房价租售比</h3><p>两张图说明一切问题</p><img src="/2019-fang-jie-fen-xi/world-major-city-income-ratio.jpg" class="" title="世界主要城市租售比"><img src="/2019-fang-jie-fen-xi/income-ratio-top10.jpg" class="" title="世界主要城市租售比top10"><p>恭喜台湾同胞喜提11名，千万不要认为南京等二线城市不在榜就是好事，只是没数据而已，不然就是屠榜了。顺便一提第一名是刚刚崩溃的委内瑞拉。第二名现在什么情况不用我详细介绍了吧。</p><p>还有另一组数据叫做可负担比率，国内几大都市同样也是名列前茅。太刺激了我就不贴了。有兴趣的自己上下面的网站去看。</p><p><a href="https://www.numbeo.com/property-investment/">numbeo-此网站可查询全球各大城市的收入与房价比值</a></p><p>另外租售比这个数据其实很好算，各位家门口的房子总价多少，每年租金多少，一除就出来了。大家可以自己算算这个数字是多少，如果超过30，世界前十的水平的。南京这个数字是多少，各位心里自然有数。</p><p>之所以把这组数据放在最后谈，就是想告诉大家这个数据才是真正的价值指标。你买房投资又不看这个，就像炒股票不谈市盈率一样，门都没进。整天扯什么K线，大盘，换手率，奉劝你趁早洗洗睡吧。韭菜，鉴定完毕！</p><p>我想这时候肯定有聪明的同学要质疑了，我要看这个前面20年房子都别买了。这里我请各位算个帐，用16年初的房价和现在的租金再算一遍你家门口房子的租售比。哎，是不是低多了？道理很简单，几年后租金能涨到补足这中间的差值，那就叫软着陆。其实这个情况过去20年间已经发生好多次了。就看你认为后面还会不会发生。</p><p>预测之前不要忘了想想现在的 GDP 增长率。</p><p>以上，没有总结，总结在 18 年已做，现在我把预测时间再加长一点未来五年，不是跌就是横。跌不跌跌多少取决于我党无敌的控制力，其实我还是蛮有信心可以稳住的 50% 吧。如果，万一，我是说万一，涨了（疯涨）。奉劝能跑的赶紧跑，肉翻的意思。</p><p>欢迎拍砖，尽量不要带脏。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>airpods-pro使用体验</title>
      <link href="/airpods-pro-shi-yong-ti-yan/"/>
      <url>/airpods-pro-shi-yong-ti-yan/</url>
      
        <content type="html"><![CDATA[<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>不说了，相信各位已经听够了。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p>长时间佩戴耳朵疼，适应了一个星期情况有所减轻。之前使用红米的 airdots 情况都要比 airpods<br>好的多。感觉原因还是尺寸大了，内部元器件实在太多，不得不在尺寸上做出妥协。PS： 我一天估计要<br>戴7个小时甚至更长。</p></li><li><p>与我的 XPS15 连接不稳，经常出现断链，杂音等情况。一加7pro 没有问题，但是之前 PC 连红米也<br>没有问题，不知道这个问题出在谁身上。</p></li></ol><h3 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h3><ol><li><p>耳塞一定要选择合适的不要选择偏小的。耳塞小了耳机嵌在耳朵中的体积更大，长时间佩戴更加不适。</p></li><li><p>使用强度高建议购买 appleCare+ 购买耳机之后 60 天内可以购买，从购买之日起增加两年的服务。<br>买它的最重要的原因就是电池寿命。如果你在苹果官方维修更换电池两个耳机收费1150+，呵呵呵。<br>苹果大法好。买了appleCare+之后电池寿命低于80%可以免费更换299￥可以延长一倍的寿命还是值得的。<br>我在网上看了一下别人使用airpods 一二代的情况，高强度使用一年电池寿命可能就只剩50%了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生面经从初级到高级</title>
      <link href="/yuan-sheng-mian-jing-cong-chu-ji-dao-gao-ji/"/>
      <url>/yuan-sheng-mian-jing-cong-chu-ji-dao-gao-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000020759924">原文链接</a></p><ol><li>函数<br>1.1函数的3种定义方法<br>1.1.1 函数声明<pre><code>//ES5function getSum()&#123;&#125;function ()&#123;&#125;//匿名函数//ES6()=&gt;&#123;&#125;//如果&#123;&#125;内容只有一行&#123;&#125;和return关键字可省,1.1.2 函数表达式(函数字面量)//ES5var sum=function()&#123;&#125;//ES6let sum=()=&gt;&#123;&#125;//如果&#123;&#125;内容只有一行&#123;&#125;和return关键字可省,</code></pre>1.1.3 构造函数<pre><code>const sum = new Function(&#39;a&#39;, &#39;b&#39; , &#39;return a + b&#39;)</code></pre>1.1.4 三种方法的对比<br>1.函数声明有预解析,而且函数声明的优先级高于变量;<br>2.使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串</li></ol><p>1.2.ES5中函数的4种调用<br>在ES5中函数内容的this指向和调用方法有关</p><p>1.2.1 函数调用模式<br>包括函数名()和匿名函数调用,this指向window</p><pre><code> function getSum() &#123;    console.log(this) //window &#125; getSum() (function() &#123;    console.log(this) //window &#125;)() var getSum=function() &#123;    console.log(this) //window &#125; getSum()</code></pre><p>1.2.2 方法调用<br>对象.方法名(),this指向对象</p><pre><code>var objList = &#123;   name: &#39;methods&#39;,   getSum: function() &#123;     console.log(this) //objList对象   &#125;&#125;objList.getSum()</code></pre><p>1.2.3 构造器调用<br>new 构造函数名(),this指向构造函数</p><pre><code>function Person() &#123;  console.log(this); //指向实例&#125;var personOne = new Person();</code></pre><p>1.2.4 间接调用<br>利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window</p><pre><code>function foo() &#123;   console.log(this);&#125;foo.apply(&#39;我是apply改变的this值&#39;);//我是apply改变的this值foo.call(&#39;我是call改变的this值&#39;);//我是call改变的this值</code></pre><p>1.3 ES6中函数的调用<br>箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误<br>箭头函数的this是和定义时有关和调用无关<br>调用就是函数调用模式</p><pre><code>(() =&gt; &#123;   console.log(this)//window&#125;)()let arrowFun = () =&gt; &#123;  console.log(this)//window&#125;arrowFun()let arrowObj = &#123;  arrFun: function() &#123;   (() =&gt; &#123;     console.log(this)//指向函数arrFun   &#125;)()   &#125; &#125; arrowObj.arrFun();</code></pre><p>1.4.call,apply和bind<br>1.IE5之前不支持call和apply,bind是ES5出来的;<br>2.call和apply可以调用函数,改变this,实现继承和借用别的对象的方法;</p><p>1.4.1 call和apply定义<br>调用方法,用一个对象替换掉另一个对象(this)<br>对象.call(新this对象,实参1,实参2,实参3…..)<br>对象.apply(新this对象,[实参1,实参2,实参3…..])</p><p>1.4.2 call和apply用法<br>1.间接调用函数,改变作用域的this值<br>2.劫持其他对象的方法</p><pre><code>var foo = &#123;  name:&quot;张三&quot;,  logName:function()&#123;    console.log(this.name);  &#125;&#125;var bar=&#123;  name:&quot;李四&quot;&#125;;foo.logName.call(bar);//李四</code></pre><p>实质是call改变了foo的this指向为bar,并调用该函数<br>3.两个函数实现继承</p><p>function Animal(name){<br>  this.name = name;<br>  this.showName = function(){<br>    console.log(this.name);<br>  }<br>}<br>function Cat(name){<br>  Animal.call(this, name);<br>}<br>var cat = new Cat(“Black Cat”);<br>cat.showName(); //Black Cat<br>4.为类数组(arguments和nodeList)添加数组方法push,pop</p><p>(function(){<br>  Array.prototype.push.call(arguments,’王五’);<br>  console.log(arguments);//[‘张三’,’李四’,’王五’]<br>})(‘张三’,’李四’)<br>5.合并数组</p><p>let arr1=[1,2,3];<br>let arr2=[4,5,6];<br>Array.prototype.push.apply(arr1,arr2); //将arr2合并到了arr1中<br>6.求数组最大值</p><p>Math.max.apply(null,arr)<br>7.判断字符类型</p><p>Object.prototype.toString.call({})<br>1.4.3 bind<br>bind是function的一个函数扩展方法，bind以后代码重新绑定了func内部的this指向,不会调用方法,不兼容IE8</p><p>var name = ‘李四’<br> var foo = {<br>   name: “张三”,<br>   logName: function(age) {<br>   console.log(this.name, age);<br>   }<br> }<br> var fooNew = foo.logName;<br> var fooNewBind = foo.logName.bind(foo);<br> fooNew(10)//李四,10<br> fooNewBind(11)//张三,11  因为bind改变了fooNewBind里面的this指向<br>1.4.4 call,apply和bind原生实现<br>call实现:</p><p>Function.prototype.newCall = function(context, …parameter) {<br>if(context.instanceof Object) context={}<br>  context.fn = this;<br>  context.fn(…parameter);<br>  delete context.fn;<br>}<br>let person = {<br>  name: ‘Abiel’<br>}<br>function sayHi(age,sex) {<br>  console.log(this.name, age, sex);<br>}<br>sayHi.newCall (person, 25, ‘男’); // Abiel 25 男<br>apply实现:</p><p>Function.prototype.newApply = function(context, parameter) {<br>  if (typeof context === ‘object’) {<br>    context = context || window<br>  } else {<br>    context = Object.create(null)<br>  }<br>  let fn = Symbol()<br>  context[fn] = this<br>  context<a href="parameter">fn</a>;<br>  delete context[fn]<br>}<br>bind实现:</p><p>Function.prototype.bind = function (context,…innerArgs) {<br>  var me = this<br>  return function (…finnalyArgs) {<br>    return me.call(context,…innerArgs,…finnalyArgs)<br>  }<br>}<br>let person = {<br>  name: ‘Abiel’<br>}<br>function sayHi(age,sex) {<br>  console.log(this.name, age, sex);<br>}<br>let personSayHi = sayHi.bind(person, 25)<br>personSayHi(‘男’)<br>1.4.5 三者异同<br>同:都是改变this指向,都可接收参数<br>异:bind和call是接收单个参数,apply是接收数组</p><p>1.5.函数的节流和防抖<br>类型    概念    应用<br>节流    某个时间段内,只执行一次    scroll,resize事件一段时间触发一次<br>防抖    处理函数截止后一段时间依次执行    scroll,resize事件触发完后一段时间触发<br>节流:</p><p>1.5.1 节流<br>let throttle = function(func, delay) {<br>    let timer = null;<br>    return function() {<br>      if (!timer) {<br>        timer = setTimeout(()=&gt; {<br>          func.apply(this, arguments);<br>          timer = null;<br>        }, delay);<br>      }<br>    };<br>  };<br>  function handle() {<br>    console.log(Math.random());<br>  }<br>  window.addEventListener(“scroll”, throttle(handle, 1000)); //事件处理函数<br>1.5.2 防抖<br>function debounce(fn, wait) {<br>    let timeout = null;<br>    return function() {<br>      if (timeout !== null) clearTimeout(timeout);//如果多次触发将上次记录延迟清除掉<br>      timeout = setTimeout(()=&gt; {<br>          fn.apply(this, arguments);<br>          timeout = null;<br>        }, wait);<br>    };<br>  }<br>  // 处理函数<br>  function handle() {<br>    console.log(Math.random());<br>  }<br>  // 滚动事件<br>  window.addEventListener(“scroll”, debounce(handle, 1000));<br>1.6.原型链<br>1.6.1 定义<br>对象继承属性的一个链条</p><p>1.6.2构造函数,实例与原型对象的关系<br>图片描述</p><p>var Person = function (name) { this.name = name; }//person是构造函数<br>var o3personTwo = new Person(‘personTwo’)//personTwo是实例<br>图片描述</p><p>原型对象都有一个默认的constructor属性指向构造函数</p><p>1.6.3 创建实例的方法<br>1.字面量</p><p>let obj={‘name’:’张三’}<br>2.Object构造函数创建</p><p>let Obj=new Object()<br>Obj.name=’张三’<br>3.使用工厂模式创建对象</p><p>function createPerson(name){<br> var o = new Object();<br> o.name = name;<br> };<br> return o;<br>}<br>var person1 = createPerson(‘张三’);<br>4.使用构造函数创建对象</p><p>function Person(name){<br> this.name = name;<br>}<br>var person1 = new Person(‘张三’);<br>1.6.4 new运算符<br>1.创了一个新对象;<br>2.this指向构造函数;<br>3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象<br>4.手动封装一个new运算符</p><p>var new2 = function (func) {<br>    var o = Object.create(func.prototype); 　　 //创建对象<br>    var k = func.call(o);　　　　　　　　　　　　　//改变this指向，把结果付给k<br>    if (typeof k === ‘object’) {　　　　　　　　　//判断k的类型是不是对象<br>        return k;　　　　　　　　　　　　　　　　　 //是，返回k<br>    } else {<br>        return o;　　　　　　　　　　　　　　　　　 //不是返回返回构造函数的执行结果<br>    }<br>}<br>1.6.5 对象的原型链<br>图片描述</p><p>1.7 继承的方式<br>JS是一门弱类型动态语言,封装和继承是他的两大特性</p><p>1.7.1 原型链继承<br>将父类的实例作为子类的原型<br>1.代码实现<br>定义父类:</p><p>// 定义一个动物类<br>function Animal (name) {<br>  // 属性<br>  this.name = name || ‘Animal’;<br>  // 实例方法<br>  this.sleep = function(){<br>    console.log(this.name + ‘正在睡觉！’);<br>  }<br>}<br>// 原型方法<br>Animal.prototype.eat = function(food) {<br>  console.log(this.name + ‘正在吃：’ + food);<br>};<br>子类:</p><p>function Cat(){<br>}<br>Cat.prototype = new Animal();<br>Cat.prototype.name = ‘cat’;</p><p>//　Test Code<br>var cat = new Cat();<br>console.log(cat.name);//cat<br>console.log(cat.eat(‘fish’));//cat正在吃：fish  undefined<br>console.log(cat.sleep());//cat正在睡觉！ undefined<br>console.log(cat instanceof Animal); //true<br>console.log(cat instanceof Cat); //true<br>2.优缺点<br>简单易于实现,但是要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行,无法实现多继承</p><p>1.7.2 构造继承<br>实质是利用call来改变Cat中的this指向<br>1.代码实现<br>子类:</p><p>function Cat(name){<br>  Animal.call(this);<br>  this.name = name || ‘Tom’;<br>}<br>2.优缺点<br>可以实现多继承,不能继承原型属性/方法</p><p>1.7.3 实例继承<br>为父类实例添加新特性，作为子类实例返回<br>1.代码实现<br>子类</p><p>function Cat(name){<br>  var instance = new Animal();<br>  instance.name = name || ‘Tom’;<br>  return instance;<br>}<br>2.优缺点<br>不限制调用方式,但不能实现多继承</p><p>1.7.4 拷贝继承<br>将父类的属性和方法拷贝一份到子类中<br>1.子类:</p><p>function Cat(name){<br>  var animal = new Animal();<br>  for(var p in animal){<br>    Cat.prototype[p] = animal[p];<br>  }<br>  Cat.prototype.name = name || ‘Tom’;<br>}<br>2.优缺点<br>支持多继承,但是效率低占用内存</p><p>1.7.5 组合继承<br>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>1.子类:</p><p>function Cat(name){<br>  Animal.call(this);<br>  this.name = name || ‘Tom’;<br>}<br>Cat.prototype = new Animal();<br>Cat.prototype.constructor = Cat;<br>1.7.6 寄生组合继承<br>function Cat(name){<br>  Animal.call(this);<br>  this.name = name || ‘Tom’;<br>}<br>(function(){<br>  // 创建一个没有实例方法的类<br>  var Super = function(){};<br>  Super.prototype = Animal.prototype;<br>  //将实例作为子类的原型<br>  Cat.prototype = new Super();<br>})();<br>1.7.7 ES6的extends继承<br>ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this,链接描述</p><p>//父类<br>class Person {<br>    //constructor是构造方法<br>    constructor(skin, language) {<br>        this.skin = skin;<br>        this.language = language;<br>    }<br>    say() {<br>        console.log(‘我是父类’)<br>    }<br>}</p><p>//子类<br>class Chinese extends Person {<br>    constructor(skin, language, positon) {<br>        //console.log(this);//报错<br>        super(skin, language);<br>        //super();相当于父类的构造函数<br>        //console.log(this);调用super后得到了this，不报错，this指向子类，相当于调用了父类.prototype.constructor.call(this)<br>        this.positon = positon;<br>    }<br>    aboutMe() {<br>        console.log(<code>$&#123;this.skin&#125; $&#123;this.language&#125;  $&#123;this.positon&#125;</code>);<br>    }<br>}</p><p>//调用只能通过new的方法得到实例,再调用里面的方法<br>let obj = new Chinese(‘红色’, ‘中文’, ‘香港’);<br>obj.aboutMe();<br>obj.say();<br>1.8.高阶函数<br>1.8.1定义<br>函数的参数是函数或返回函数</p><p>1.8.2 常见的高阶函数<br>map,reduce,filter,sort</p><p>1.8.3 柯里化<br>1.定义:只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p><p>fn(a,b,c,d)=&gt;fn(a)(b)(c)(d)<br>2.代码实现:</p><p>const currying = fn =&gt; {<br>const len = fn.length<br>return function curr (…args1) {<br>    if (args1.length &gt;= len) {<br>         return fn(…args1)<br>    }<br>    return (…args2) =&gt; curr(…args1, …args2)<br>    }<br>}</p><p>1.8.4 反柯里化<br>1.定义:</p><p>obj.func(arg1, arg2)=&gt;func(obj, arg1, arg2)<br>2.代码实现:</p><p>Function.prototype.uncurrying = function() {<br>  var that = this;<br>  return function() {<br>    return Function.prototype.call.apply(that, arguments);<br>  }<br>};</p><p>function sayHi () {<br>  return “Hello “ + this.value +” “+[].slice.call(arguments);<br>}<br>let sayHiuncurrying=sayHi.uncurrying();<br>console.log(sayHiuncurrying({value:’world’},”hahaha”));<br>1.8.5偏函数<br>1.定义:指定部分参数来返回一个新的定制函数的形式<br>2.例子:</p><p>function foo(a, b, c) {<br>  return a + b + c;<br>}<br>function func(a, b) {<br>  return foo(a,b,8);<br>}<br>2.对象<br>2.1.对象的声明方法<br>2.1.1 字面量<br>var test2 = {x:123,y:345};<br>console.log(test2);//{x:123,y:345};<br>console.log(test2.x);//123<br>console.log(test2.<strong>proto</strong>.x);//undefined<br>console.log(test2.<strong>proto</strong>.x === test2.x);//false<br>2.1.2 构造函数<br>var test1 = new Object({x:123,y:345});<br>console.log(test1);//{x:123,y:345}<br>console.log(test1.x);//123<br>console.log(test1.<strong>proto</strong>.x);//undefined<br>console.log(test1.<strong>proto</strong>.x === test1.x);//false<br>new的作用:<br>1.创了一个新对象;<br>2.this指向构造函数;<br>3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象</p><p>2.1.3 内置方法<br>Obejct.create(obj,descriptor),obj是对象,describe描述符属性(可选)</p><p>let test = Object.create({x:123,y:345});<br>console.log(test);//{}<br>console.log(test.x);//123<br>console.log(test.<strong>proto</strong>.x);//3<br>console.log(test.<strong>proto</strong>.x === test.x);//true<br>2.1.4 三种方法的优缺点<br>1.功能:都能实现对象的声明,并能够赋值和取值<br>2.继承性:内置方法创建的对象继承到<strong>proto</strong>属性上<br>3.隐藏属性:三种声明方法会默认为内部的每个成员（属性或方法）生成一些隐藏属性，这些隐藏属性是可以读取和可配置的,属性分类见下面<br>4.属性读取:Object.getOwnPropertyDescriptor()或getOwnPropertyDescriptor()<br>5.属性设置:Object.definePropertype或Object.defineProperties</p><p>2.2.对象的属性<br>2.2.1 属性分类<br>1.数据属性4个特性:<br>configurable(可配置),enumerable(可枚举),writable(可修改),value(属性值)</p><p>2.访问器属性2个特性:<br>get(获取),set(设置)</p><p>3.内部属性<br>由JavaScript引擎内部使用的属性;<br>不能直接访问,但是可以通过对象内置方法间接访问,如:[[Prototype]]可以通过 Object.getPrototypeOf()访问;<br>内部属性用[[]]包围表示,是一个抽象操作,没有对应字符串类型的属性名,如[[Prototype]].</p><p>2.2.2 属性描述符<br>1.定义:将一个属性的所有特性编码成一个对象返回<br>2.描述符的属性有:数据属性和访问器属性<br>3.使用范围:<br>作为方法Object.defineProperty, Object.getOwnPropertyDescriptor, Object.create的第二个参数,</p><p>2.2.3 属性描述符的默认值<br>1.访问对象存在的属性</p><p>特性名    默认值<br>value    对应属性值<br>get    对应属性值<br>set    undefined<br>writable    true<br>enumerable    true<br>configurable    true<br>所以通过上面三种声明方法已存在的属性都是有这些默认描述符<br>2.访问对象不存在的属性</p><p>特性名    默认值<br>value    undefined<br>get    undefined<br>set    undefined<br>writable    false<br>enumerable    false<br>configurable    false<br>2.2.3 描述符属性的使用规则<br>get,set与wriable,value是互斥的,如果有交集设置会报错</p><p>2.2.4 属性定义<br>1.定义属性的函数有两个:Object.defineProperty和Object.defineProperties.例如:<br>Object.defineProperty(obj, propName, desc)</p><p>2.在引擎内部,会转换成这样的方法调用:<br>obj.<a href="propName, desc, true">[DefineOwnProperty]</a></p><p>2.2.5 属性赋值<br>1.赋值运算符(=)就是在调用[[Put]].比如:<br>obj.prop = v;</p><p>2.在引擎内部,会转换成这样的方法调用:<br>obj.<a href="&quot;prop&quot;, v, isStrictModeOn">[Put]</a></p><p>2.2.6 判断对象的属性<br>名称    含义    用法<br>in    如果指定的属性在指定的对象或其原型链中，则in 运算符返回true    ‘name’ in test //true<br>hasOwnProperty()    只判断自身属性    test.hasOwnProperty(‘name’) //true<br>.或[]    对象或原型链上不存在该属性，则会返回undefined    test.name //“lei” test[“name”] //“lei”<br>2.3.Symbol<br>2.3.1概念<br>是一种数据类型;<br>不能new,因为Symbol是一个原始类型的值，不是对象。</p><p>2.3.2 定义方法<br>Symbol(),可以传参</p><p>var s1 = Symbol();<br>var s2 = Symbol();<br>s1 === s2 // false</p><p>// 有参数的情况<br>var s1 = Symbol(“foo”);<br>var s2 = Symbol(“foo”);<br>s1 === s2 // false<br>2.3.3 用法<br>1.不能与其他类型的值进行运算;<br>2.作为属性名</p><p>let mySymbol = Symbol();</p><p>// 第一种写法<br>var a = {};<br>a[mySymbol] = ‘Hello!’;</p><p>// 第二种写法<br>var a = {<br>  [mySymbol]: ‘Hello!’<br>};</p><p>// 第三种写法<br>var a = {};<br>Object.defineProperty(a, mySymbol, { value: ‘Hello!’ });</p><p>// 以上写法都得到同样结果<br>a[mySymbol] // “Hello!”<br>3.作为对象属性名时，不能用点运算符,可以用[]</p><p>let a = {};<br>let name = Symbol();<br>a.name = ‘lili’;<br>a[name] = ‘lucy’;<br>console.log(a.name,a[name]);<br>4.遍历不会被for…in、for…of和Object.keys()、Object.getOwnPropertyNames()取到该属性</p><p>2.3.4 Symbol.for<br>1.定义:在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值<br>2.举例:</p><p>var s1 = Symbol.for(‘foo’);<br>var s2 = Symbol.for(‘foo’);<br>s1 === s2 // true<br>2.3.5 Symbol.keyFor<br>1.定义:返回一个已登记的Symbol类型值的key<br>2.举例:</p><p>var s1 = Symbol.for(“foo”);<br>Symbol.keyFor(s1) // “foo”</p><p>var s2 = Symbol(“foo”);<br>Symbol.keyFor(s2) // undefined<br>2.4.遍历<br>2.4.1 一级对象遍历方法<br>方法    特性<br>for … in    遍历对象自身的和继承的可枚举属性(不含Symbol属性)<br>Object.keys(obj)    返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)<br>Object.getOwnPropertyNames(obj)    返回一个数组,包括对象自身的所有可枚举属性(不含Symbol属性)<br>Object.getOwnPropertySymbols(obj)    返回一个数组,包含对象自身的所有Symbol属性<br>Reflect.ownKeys(obj)    返回一个数组,包含对象自身的所有(不枚举、可枚举和Symbol)属性<br>Reflect.enumerate(obj)    返回一个Iterator对象,遍历对象自身的和继承的所有可枚举属性(不含Symbol属性)<br>总结:1.只有Object.getOwnPropertySymbols(obj)和Reflect.ownKeys(obj)可以拿到Symbol属性<br>2.只有Reflect.ownKeys(obj)可以拿到不可枚举属性</p><p>2.4.2 多级对象遍历<br>数据模型:</p><p>var treeNodes = [<br>    {<br>     id: 1,<br>     name: ‘1’,<br>     children: [<br>       {<br>        id: 11,<br>        name: ‘11’,<br>        children: [<br>         {<br>          id: 111,<br>          name: ‘111’,<br>          children:[]<br>          },<br>          {<br>            id: 112,<br>            name: ‘112’<br>           }<br>          ]<br>         },<br>         {<br>          id: 12,<br>          name: ‘12’,<br>          children: []<br>         }<br>         ],<br>         users: []<br>        },<br>      ];<br>递归:</p><p>var parseTreeJson = function(treeNodes){<br>      if (!treeNodes || !treeNodes.length) return;</p><pre><code>   for (var i = 0, len = treeNodes.length; i &lt; len; i++) &#123;        var childs = treeNodes[i].children;        console.log(treeNodes[i].id);        if(childs &amp;&amp; childs.length &gt; 0)&#123;             parseTreeJson(childs);        &#125;   &#125;&#125;;console.log(&#39;------------- 递归实现 ------------------&#39;);parseTreeJson(treeNodes);</code></pre><p>2.5.深度拷贝<br>2.5.1 Object.assign<br>1.定义:将源对象（source）的所有可枚举属性，复制到目标对象（target）<br>2.用法:</p><p>合并多个对象<br>var target = { a: 1, b: 1 };<br>var source1 = { b: 2, c: 2 };<br>var source2 = { c: 3 };<br>Object.assign(target, source1, source2);<br>3.注意:<br>这个是伪深度拷贝,只能拷贝第一层</p><p>2.5.2 JSON.stringify<br>1.原理:是将对象转化为字符串,而字符串是简单数据类型</p><p>2.5.3 递归拷贝<br>function deepClone(source){<br>  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象<br>  for(let keys in source){ // 遍历目标<br>    if(source.hasOwnProperty(keys)){<br>      if(source[keys] &amp;&amp; typeof source[keys] === ‘object’){ // 如果值是对象，就递归一下<br>        targetObj[keys] = source[keys].constructor === Array ? [] : {};<br>        targetObj[keys] = deepClone(source[keys]);<br>      }else{ // 如果不是，就直接赋值<br>        targetObj[keys] = source[keys];<br>      }<br>    }<br>  }<br>  return targetObj;<br>}  </p><p>2.6.数据拦截<br>定义:利用对象内置方法,设置属性,进而改变对象的属性值</p><p>2.6.1 Object.defineProterty<br>1.ES5出来的方法;<br>2.三个参数:对象(必填),属性值(必填),描述符(可选);<br>3.defineProterty的描述符属性</p><p>数据属性:value,writable,configurable,enumerable<br>访问器属性:get,set<br>注:不能同时设置value和writable,这两对属性是互斥的<br>4.拦截对象的两种情况:</p><p>let obj = {name:’’,age:’’,sex:’’  },<br>    defaultName = [“这是姓名默认值1”,”这是年龄默认值1”,”这是性别默认值1”];<br>  Object.keys(obj).forEach(key =&gt; {<br>    Object.defineProperty(obj, key, {<br>      get() {<br>        return defaultName;<br>      },<br>      set(value) {<br>        defaultName = value;<br>      }<br>    });<br>  });</p><p>  console.log(obj.name);<br>  console.log(obj.age);<br>  console.log(obj.sex);<br>  obj.name = “这是改变值1”;<br>  console.log(obj.name);<br>  console.log(obj.age);<br>  console.log(obj.sex);</p><p>  let objOne={},defaultNameOne=”这是默认值2”;<br>  Object.defineProperty(obj, ‘name’, {<br>      get() {<br>        return defaultNameOne;<br>      },<br>      set(value) {<br>        defaultNameOne = value;<br>      }<br>  });<br>  console.log(objOne.name);<br>  objOne.name = “这是改变值2”;<br>  console.log(objOne.name);<br>5.拦截数组变化的情况</p><p>let a={};<br>bValue=1;<br>Object.defineProperty(a,”b”,{<br>    set:function(value){<br>        bValue=value;<br>        console.log(“setted”);<br>    },<br>    get:function(){<br>        return bValue;<br>    }<br>});<br>a.b;//1<br>a.b=[];//setted<br>a.b=[1,2,3];//setted<br>a.b[1]=10;//无输出<br>a.b.push(4);//无输出<br>a.b.length=5;//无输出<br>a.b;//[1,10,3,4,undefined];</p><p>结论:defineProperty无法检测数组索引赋值,改变数组长度的变化;<br>    但是通过数组方法来操作可以检测到</p><p>6.存在的问题</p><p>不能监听数组索引赋值和改变长度的变化<br>必须深层遍历嵌套的对象,因为defineProterty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择</p><p>2.6.2 proxy<br>1.ES6出来的方法,实质是对对象做了一个拦截,并提供了13个处理方法<br>13个方法详情请戳,阮一峰的proxy介绍</p><p>2.两个参数:对象和行为函数</p><p>let handler = {<br>    get(target, key, receiver) {<br>      console.log(“get”, key);<br>      return Reflect.get(target, key, receiver);<br>    },<br>    set(target, key, value, receiver) {<br>      console.log(“set”, key, value);<br>      return Reflect.set(target, key, value, receiver);<br>    }<br>  };<br>  let proxy = new Proxy(obj, handler);<br>  proxy.name = “李四”;<br>  proxy.age = 24;<br>3.问题和优点<br>reflect对象没有构造函数<br>可以监听数组索引赋值,改变数组长度的变化,<br>是直接监听对象的变化,不用深层遍历</p><p>2.6.3 defineProterty和proxy的对比<br>1.defineProterty是es5的标准,proxy是es6的标准;</p><p>2.proxy可以监听到数组索引赋值,改变数组长度的变化;</p><p>3.proxy是监听对象,不用深层遍历,defineProterty是监听属性;</p><p>3.利用defineProterty实现双向数据绑定(vue2.x采用的核心)<br>请戳,剖析Vue原理&amp;实现双向绑定MVVM<br>4.利用proxy实现双向数据绑定(vue3.x会采用)</p><p>3.数组<br>数组基本上考察数组方法多一点,所以这里就单纯介绍常见的场景数组的方法,还有很多场景后续补充;<br>本文主要从应用来讲数组api的一些骚操作;<br>如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等；<br>上面这些应用场景你可以用一行代码实现？</p><p>3.1 扁平化n维数组<br>1.终极篇</p><p>[1,[2,3]].flat(2) //[1,2,3]<br>[1,[2,3,[4,5]].flat(3) //[1,2,3,4,5]<br>[1,[2,3,[4,5]]].toString()  //‘1,2,3,4,5’<br>[1[2,3,[4,5[…]].flat(Infinity) //[1,2,3,4…n]<br>Array.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大</p><p>2.开始篇</p><p>function flatten(arr) {<br>    while(arr.some(item=&gt;Array.isArray(item))) {<br>        arr = [].concat(…arr);<br>    }<br>    return arr;<br>}<br>flatten([1,[2,3]]) //[1,2,3]<br>flatten([1,[2,3,[4,5]]) //[1,2,3,4,5]<br>实质是利用递归和数组合并方法concat实现扁平</p><p>3.2 去重<br>1.终极篇</p><p>Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]<br>[…new Set([1,2,3,3,4,4])] //[1,2,3,4]<br>set是ES6新出来的一种一种定义不重复数组的数据类型<br>Array.from是将类数组转化为数组<br>…是扩展运算符,将set里面的值转化为字符串<br>2.开始篇</p><p>Array.prototype.distinct = nums =&gt; {<br>const map = {}<br>const result = []<br>for (const n of nums) {<br>    if (!(n in map)) {<br>        map[n] = 1<br>        result.push(n)<br>    }<br>}<br>return result<br>}<br>[1,2,3,3,4,4].distinct(); //[1,2,3,4]<br>取新数组存值,循环两个数组值相比较</p><p>3.3排序<br>1.终极篇</p><p>[1,2,3,4].sort((a, b) =&gt; a - b); // [1, 2,3,4],默认是升序<br>[1,2,3,4].sort((a, b) =&gt; b - a); // [4,3,2,1] 降序<br>sort是js内置的排序方法,参数为一个函数<br>2.开始篇<br>冒泡排序:</p><p>Array.prototype.bubleSort=function () {<br>    let arr=this,<br>        len = arr.length;<br>    for (let outer = len; outer &gt;= 2; outer–) {<br>      for (let inner = 0; inner &lt;= outer - 1; inner++) {<br>        if (arr[inner] &gt; arr[inner + 1]) {<br>          //升序<br>          [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]];<br>          console.log([arr[inner], arr[inner + 1]]);<br>        }<br>      }<br>    }<br>    return arr;<br>  }<br>[1,2,3,4].bubleSort() //[1,2,3,4]<br>选择排序</p><pre><code>Array.prototype.selectSort=function () &#123;    let arr=this,        len = arr.length;    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;for (let j = i, len = arr.length; j &lt; len; j++) &#123;  if (arr[i] &gt; arr[j]) &#123;    [arr[i], arr[j]] = [arr[j], arr[i]];  &#125;&#125;</code></pre><p>  }<br>    return arr;<br>  }<br>  [1,2,3,4].selectSort() //[1,2,3,4]<br>3.4最大值<br>1.终极篇</p><p>Math.max(…[1,2,3,4]) //4<br>Math.max.apply(this,[1,2,3,4]) //4<br>[1,2,3,4].reduce( (prev, cur,curIndex,arr)=&gt; {<br> return Math.max(prev,cur);<br>},0) //4<br>Math.max()是Math对象内置的方法,参数是字符串;<br>reduce是ES5的数组api,参数有函数和默认初始值;<br>函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组)</p><p>2.开始篇<br>先排序再取值</p><p>3.5求和<br>1.终极篇</p><p>[1,2,3,4].arr.reduce(function (prev, cur) {<br>   return prev + cur;<br> },0) //10<br>2.开始篇</p><p>function sum(arr) {<br>  var len = arr.length;<br>  if(len == 0){<br>    return 0;<br>  } else if (len == 1){<br>    return arr[0];<br>  } else {<br>    return arr[0] + sum(arr.slice(1));<br>  }<br>}<br>sum([1,2,3,4]) //10<br>利用slice截取改变数组,再利用递归求和</p><p>3.6合并<br>1.终极篇</p><p>[1,2,3,4].concat([5,6]) //[1,2,3,4,5,6]<br>[…[1,2,3,4],…[4,5]] //[1,2,3,4,5,6]<br>let arrA = [1, 2], arrB = [3, 4]<br>Array.prototype.push.apply(arrA, arrB))//arrA值为[1,2,3,4]<br>2.开始篇</p><p>let arr=[1,2,3,4];<br>  [5,6].map(item=&gt;{<br>   arr.push(item)<br> })<br> //arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]<br>3.7判断是否包含值<br>1.终极篇</p><p>[1,2,3].includes(4) //false<br>[1,2,3].indexOf(4) //-1 如果存在换回索引<br>[1, 2, 3].find((item)=&gt;item===3)) //3 如果数组中无值返回undefined<br>[1, 2, 3].findIndex((item)=&gt;item===3)) //2 如果数组中无值返回-1<br>includes(),find(),findIndex()是ES6的api</p><p>2.开始篇</p><p>[1,2,3].some(item=&gt;{<br>  return item===3<br>}) //true 如果不包含返回false<br>3.8类数组转化<br>1.终极篇</p><p>Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)<br>Array.prototype.slice.apply(arguments)<br>Array.from(arguments)<br>[…arguments]<br>类数组:表示有length属性,但是不具备数组的方法<br>call,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法<br>Array.from是将类似数组或可迭代对象创建为数组<br>…是将类数组扩展为字符串,再定义为数组</p><p>2.开始篇</p><p>Array.prototype.slice = function(start,end){<br>      var result = new Array();<br>      start = start || 0;<br>      end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键<br>      for(var i = start; i &lt; end; i++){<br>           result.push(this[i]);<br>      }<br>      return result;<br> }<br>3.9每一项设置值<br>1.终极篇</p><p>[1,2,3].fill(false) //[false,false,false]<br>fill是ES6的方法<br>2.开始篇</p><p>[1,2,3].map(() =&gt; 0)<br>3.10每一项是否满足<br>[1,2,3].every(item=&gt;{return item&gt;2}) //false<br>every是ES5的api,每一项满足返回 true</p><p>3.11有一项满足<br>[1,2,3].some(item=&gt;{return item&gt;2}) //true<br>some是ES5的api,有一项满足返回 true</p><p>3.12.过滤数组<br>[1,2,3].filter(item=&gt;{return item&gt;2}) //[3]<br>filter是ES5的api,返回满足添加的项的数组</p><p>3.13对象和数组转化<br>Object.keys({name:’张三’,age:14}) //[‘name’,’age’]<br>Object.values({name:’张三’,age:14}) //[‘张三’,14]<br>Object.entries({name:’张三’,age:14}) //[[name,’张三’],[age,14]]<br>Object.fromEntries([name,’张三’],[age,14]) //ES10的api,Chrome不支持 , firebox输出{name:’张三’,age:14}<br>3.14 对象数组<br>[{count:1},{count:2},{count:3}].reduce((p, e)=&gt;p+(e.count), 0)<br>4.数据结构篇<br>数据结构是计算机存储、组织数据的方式,算法是系统描述解决问题的策略。了解基本的数据结构和算法可以提高代码的性能和质量。<br>也是程序猿进阶的一个重要技能。<br>手撸代码实现栈,队列,链表,字典,二叉树,动态规划和贪心算法<br>4.1 栈<br>栈的特点：先进后出</p><p>class Stack {<br>    constructor() {<br>      this.items = [];<br>    }</p><pre><code>// 入栈push(element) &#123;  this.items.push(element);&#125;// 出栈pop() &#123;  return this.items.pop();&#125;// 末位get peek() &#123;  return this.items[this.items.length - 1];&#125;// 是否为空栈get isEmpty() &#123;  return !this.items.length;&#125;// 长度get size() &#123;  return this.items.length;&#125;// 清空栈clear() &#123;  this.items = [];&#125;</code></pre><p>  }</p><p>  // 实例化一个栈<br>  const stack = new Stack();<br>  console.log(stack.isEmpty); // true</p><p>  // 添加元素<br>  stack.push(5);<br>  stack.push(8);</p><p>  // 读取属性再添加<br>  console.log(stack.peek); // 8<br>  stack.push(11);<br>  console.log(stack.size); // 3<br>  console.log(stack.isEmpty); // false<br>4.2 队列<br>队列：先进先出</p><p>  class Queue {<br>    constructor(items) {<br>      this.items = items || [];<br>    }</p><pre><code>enqueue(element) &#123;  this.items.push(element);&#125;dequeue() &#123;  return this.items.shift();&#125;front() &#123;  return this.items[0];&#125;clear() &#123;  this.items = [];&#125;get size() &#123;  return this.items.length;&#125;get isEmpty() &#123;  return !this.items.length;&#125;print() &#123;  console.log(this.items.toString());&#125;</code></pre><p>  }</p><p>  const queue = new Queue();<br>  console.log(queue.isEmpty); // true</p><p>  queue.enqueue(“John”);<br>  queue.enqueue(“Jack”);<br>  queue.enqueue(“Camila”);<br>  console.log(queue.size); // 3<br>  console.log(queue.isEmpty); // false<br>  queue.dequeue();<br>  queue.dequeue();</p><p>4.3 链表<br>链表:存贮有序元素的集合,<br>但是不同于数组,每个元素是一个存贮元素本身的节点和指向下一个元素引用组成<br>要想访问链表中间的元素,需要从起点开始遍历找到所需元素</p><p>class Node {<br>    constructor(element) {<br>      this.element = element;<br>      this.next = null;<br>    }<br>  }</p><p>  // 链表<br>  class LinkedList {<br>    constructor() {<br>      this.head = null;<br>      this.length = 0;<br>    }</p><pre><code>// 追加元素append(element) &#123;  const node = new Node(element);  let current = null;  if (this.head === null) &#123;    this.head = node;  &#125; else &#123;    current = this.head;    while (current.next) &#123;      current = current.next;    &#125;    current.next = node;  &#125;  this.length++;&#125;// 任意位置插入元素insert(position, element) &#123;  if (position &gt;= 0 &amp;&amp; position &lt;= this.length) &#123;    const node = new Node(element);    let current = this.head;    let previous = null;    let index = 0;    if (position === 0) &#123;      this.head = node;    &#125; else &#123;      while (index++ &lt; position) &#123;        previous = current;        current = current.next;      &#125;      node.next = current;      previous.next = node;    &#125;    this.length++;    return true;  &#125;  return false;&#125;// 移除指定位置元素removeAt(position) &#123;  // 检查越界值  if (position &gt; -1 &amp;&amp; position &lt; length) &#123;    let current = this.head;    let previous = null;    let index = 0;    if (position === 0) &#123;      this.head = current.next;    &#125; else &#123;      while (index++ &lt; position) &#123;        previous = current;        current = current.next;      &#125;      previous.next = current.next;    &#125;    this.length--;    return current.element;  &#125;  return null;&#125;// 寻找元素下标findIndex(element) &#123;  let current = this.head;  let index = -1;  while (current) &#123;    if (element === current.element) &#123;      return index + 1;    &#125;    index++;    current = current.next;  &#125;  return -1;&#125;// 删除指定文档remove(element) &#123;  const index = this.findIndex(element);  return this.removeAt(index);&#125;isEmpty() &#123;  return !this.length;&#125;size() &#123;  return this.length;&#125;// 转为字符串toString() &#123;  let current = this.head;  let string = &quot;&quot;;  while (current) &#123;    string += ` $&#123;current.element&#125;`;    current = current.next;  &#125;  return string;&#125;</code></pre><p>  }<br>  const linkedList = new LinkedList();</p><p>  console.log(linkedList);<br>  linkedList.append(2);<br>  linkedList.append(6);<br>  linkedList.append(24);<br>  linkedList.append(152);</p><p>  linkedList.insert(3, 18);<br>  console.log(linkedList);<br>  console.log(linkedList.findIndex(24));  </p><p>4.4 字典<br>字典：类似对象，以key，value存贮值</p><p>class Dictionary {<br>    constructor() {<br>      this.items = {};<br>    }</p><pre><code>set(key, value) &#123;  this.items[key] = value;&#125;get(key) &#123;  return this.items[key];&#125;remove(key) &#123;  delete this.items[key];&#125;get keys() &#123;  return Object.keys(this.items);&#125;get values() &#123;  /*也可以使用ES7中的values方法return Object.values(this.items)*/  // 在这里我们通过循环生成一个数组并输出  return Object.keys(this.items).reduce((r, c, i) =&gt; &#123;    r.push(this.items[c]);    return r;  &#125;, []);&#125;</code></pre><p>  }<br>  const dictionary = new Dictionary();<br>  dictionary.set(“Gandalf”, “<a href="mailto:gandalf@email.com">gandalf@email.com</a>“);<br>  dictionary.set(“John”, “<a href="mailto:johnsnow@email.com">johnsnow@email.com</a>“);<br>  dictionary.set(“Tyrion”, “<a href="mailto:tyrion@email.com">tyrion@email.com</a>“);</p><p>  console.log(dictionary);<br>  console.log(dictionary.keys);<br>  console.log(dictionary.values);<br>  console.log(dictionary.items);</p><p>4.5 二叉树<br>特点：每个节点最多有两个子树的树结构</p><p>class NodeTree {<br>    constructor(key) {<br>      this.key = key;<br>      this.left = null;<br>      this.right = null;<br>    }<br>  }</p><p>  class BinarySearchTree {<br>    constructor() {<br>      this.root = null;<br>    }</p><pre><code>insert(key) &#123;  const newNode = new NodeTree(key);  const insertNode = (node, newNode) =&gt; &#123;    if (newNode.key &lt; node.key) &#123;      if (node.left === null) &#123;        node.left = newNode;      &#125; else &#123;        insertNode(node.left, newNode);      &#125;    &#125; else &#123;      if (node.right === null) &#123;        node.right = newNode;      &#125; else &#123;        insertNode(node.right, newNode);      &#125;    &#125;  &#125;;  if (!this.root) &#123;    this.root = newNode;  &#125; else &#123;    insertNode(this.root, newNode);  &#125;&#125;//访问树节点的三种方式:中序,先序,后序inOrderTraverse(callback) &#123;  const inOrderTraverseNode = (node, callback) =&gt; &#123;    if (node !== null) &#123;      inOrderTraverseNode(node.left, callback);      callback(node.key);      inOrderTraverseNode(node.right, callback);    &#125;  &#125;;  inOrderTraverseNode(this.root, callback);&#125;min(node) &#123;  const minNode = node =&gt; &#123;    return node ? (node.left ? minNode(node.left) : node) : null;  &#125;;  return minNode(node || this.root);&#125;max(node) &#123;  const maxNode = node =&gt; &#123;    return node ? (node.right ? maxNode(node.right) : node) : null;  &#125;;  return maxNode(node || this.root);&#125;</code></pre><p>  }<br>  const tree = new BinarySearchTree();<br>  tree.insert(11);<br>  tree.insert(7);<br>  tree.insert(5);<br>  tree.insert(3);<br>  tree.insert(9);<br>  tree.insert(8);<br>  tree.insert(10);<br>  tree.insert(13);<br>  tree.insert(12);<br>  tree.insert(14);<br>  tree.inOrderTraverse(value =&gt; {<br>    console.log(value);<br>  });</p><p>  console.log(tree.min());<br>  console.log(tree.max());</p><p>5.算法篇<br>5.1 冒泡算法<br>冒泡排序，选择排序，插入排序，此处不做赘述，请戳 排序</p><p>5.2 斐波那契<br>特点：第三项等于前面两项之和</p><p>function fibonacci(num) {<br>    if (num === 1 || num === 2) {<br>        return 1<br>    }<br>    return fibonacci(num - 1) + fibonacci(num - 2)<br>  }<br>5.3 动态规划<br>特点：通过全局规划,将大问题分割成小问题来取最优解<br>案例：最少硬币找零<br>美国有以下面额(硬币）：d1=1, d2=5, d3=10, d4=25<br>如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（ 1美分)</p><p>class MinCoinChange {</p><p>constructor(coins) {<br>    this.coins = coins<br>    this.cache = {}<br>}</p><p>makeChange(amount) {<br>    if (!amount) return []<br>    if (this.cache[amount]) return this.cache[amount]<br>    let min = [], newMin, newAmount<br>    this.coins.forEach(coin =&gt; {<br>        newAmount = amount - coin<br>        if (newAmount &gt;= 0) {<br>            newMin = this.makeChange(newAmount)<br>        }<br>        if (newAmount &gt;= 0 &amp;&amp;<br>             (newMin.length &lt; min.length - 1 || !min.length) &amp;&amp;<br>             (newMin.length || !newAmount)) {<br>            min = [coin].concat(newMin)<br>        }<br>    })<br>    return (this.cache[amount] = min)<br>}<br>}</p><p>const rninCoinChange = new MinCoinChange([1, 5, 10, 25])<br>console.log(rninCoinChange.makeChange(36))<br>// [1, 10, 25]<br>const minCoinChange2 = new MinCoinChange([1, 3, 4])<br>console.log(minCoinChange2.makeChange(6))<br>// [3, 3]<br>5.4 贪心算法<br>特点：通过最优解来解决问题<br>用贪心算法来解决2.3中的案例</p><p>class MinCoinChange2 {</p><p>constructor(coins) {<br>    this.coins = coins<br>}</p><p>makeChange(amount) {<br>    const change = []<br>    let total = 0<br>    this.coins.sort((a, b) =&gt; a &lt; b).forEach(coin =&gt; {<br>        if ((total + coin) &lt;= amount) {<br>            change.push(coin)<br>            total += coin<br>        }<br>    })<br>    return change<br>}<br>}<br>const rninCoinChange2 = new MinCoinChange2 ( [ 1, 5, 10, 25])<br>console.log (rninCoinChange2. makeChange (36))<br>6 设计模式<br>设计模式如果应用到项目中，可以实现代码的复用和解耦，提高代码质量。 本文主要介绍14种设计模式<br>写UI组件,封装框架必备<br>6.1 简单工厂模式<br>1.定义：又叫静态工厂方法，就是创建对象，并赋予属性和方法<br>2.应用：抽取类相同的属性和方法封装到对象上<br>3.代码：</p><pre><code>let UserFactory = function (role) &#123;</code></pre><p>  function User(opt) {<br>    this.name = opt.name;<br>    this.viewPage = opt.viewPage;<br>  }<br>  switch (role) {<br>    case ‘superAdmin’:<br>      return new User(superAdmin);<br>      break;<br>    case ‘admin’:<br>      return new User(admin);<br>      break;<br>    case ‘user’:<br>      return new User(user);<br>      break;<br>    default:<br>      throw new Error(‘参数错误, 可选参数:superAdmin、admin、user’)<br>  }<br>}</p><p>//调用<br>let superAdmin = UserFactory(‘superAdmin’);<br>let admin = UserFactory(‘admin’)<br>let normalUser = UserFactory(‘user’)<br>//最后得到角色,可以调用<br>6.2工厂方法模式<br>1.定义：对产品类的抽象使其创建业务主要负责用于创建多类产品的实例<br>2.应用:创建实例<br>3.代码:</p><p>var Factory=function(type,content){<br>  if(this instanceof Factory){<br>    var s=new this<a href="content">type</a>;<br>    return s;<br>  }else{<br>    return new Factory(type,content);<br>  }<br>}</p><p>//工厂原型中设置创建类型数据对象的属性<br>Factory.prototype={<br>  Java:function(content){<br>    console.log(‘Java值为’,content);<br>  },<br>  PHP:function(content){<br>    console.log(‘PHP值为’,content);<br>  },<br>  Python:function(content){<br>    console.log(‘Python值为’,content);<br>  },<br>}</p><p>//测试用例<br>Factory(‘Python’,’我是Python’);<br>6.3原型模式<br>1.定义:设置函数的原型属性<br>2.应用:实现继承<br>3.代码:</p><p>function Animal (name) {<br>  // 属性<br>  this.name = name || ‘Animal’;<br>  // 实例方法<br>  this.sleep = function(){<br>    console.log(this.name + ‘正在睡觉！’);<br>  }<br>}<br>// 原型方法<br>Animal.prototype.eat = function(food) {<br>  console.log(this.name + ‘正在吃：’ + food);<br>};</p><p>function Cat(){<br>}<br>Cat.prototype = new Animal();<br>Cat.prototype.name = ‘cat’;</p><p>//　Test Code<br>var cat = new Cat();<br>console.log(cat.name);//cat<br>console.log(cat.eat(‘fish’));//cat正在吃：fish  undefined<br>console.log(cat.sleep());//cat正在睡觉！ undefined<br>console.log(cat instanceof Animal); //true<br>console.log(cat instanceof Cat); //true<br>6.4单例模式<br>1.定义:只允许被实例化依次的类<br>2.应用:提供一个命名空间<br>3.代码:</p><p>let singleCase = function(name){<br>    this.name = name;<br>};<br>singleCase.prototype.getName = function(){<br>    return this.name;<br>}<br>// 获取实例对象<br>let getInstance = (function() {<br>    var instance = null;<br>    return function(name) {<br>        if(!instance) {//相当于一个一次性阀门,只能实例化一次<br>            instance = new singleCase(name);<br>        }<br>        return instance;<br>    }<br>})();<br>// 测试单体模式的实例,所以one===two<br>let one = getInstance(“one”);<br>let two = getInstance(“two”);<br>6.5外观模式<br>1.定义:为子系统中的一组接口提供一个一致的界面<br>2.应用:简化复杂接口<br>3.代码:<br>外观模式</p><p>6.6适配器模式<br>1.定义:将一个接口转换成客户端需要的接口而不需要去修改客户端代码，使得不兼容的代码可以一起工作<br>2.应用:适配函数参数<br>3.代码:<br>适配器模式</p><p>6.7装饰者模式<br>1.定义:不改变原对象的基础上,给对象添加属性或方法<br>2.代码</p><p>let decorator=function(input,fn){<br>  //获取事件源<br>  let input=document.getElementById(input);<br>  //若事件源已经绑定事件<br>  if(typeof input.onclick==’function’){<br>    //缓存事件源原有的回调函数<br>    let oldClickFn=input.onclick;<br>    //为事件源定义新事件<br>    input.onclick=function(){<br>      //事件源原有回调函数<br>      oldClickFn();<br>      //执行事件源新增回调函数<br>      fn();<br>    }<br>  }else{<br>    //未绑定绑定<br>    input.onclick=fn;<br>  }<br>}</p><p>//测试用例<br>decorator(‘textInp’,function(){<br>  console.log(‘文本框执行啦’);<br>})<br>decorator(‘btn’,function(){<br>  console.log(‘按钮执行啦’);<br>})<br>6.8桥接模式<br>1.定义:将抽象部分与它的实现部分分离，使它们都可以独立地变化<br>2.代码<br>桥接模式</p><p>6.9模块方法模式<br>1.定义:定义一个模板,供以后传不同参数调用<br>2.代码:<br>模块方法模式</p><p>6.10.观察者模式<br>1.作用:解决类与对象,对象与对象之间的耦合<br>2.代码:</p><p>let Observer=<br>  (function(){<br>    let _message={};<br>    return {<br>      //注册接口,<br>        //1.作用:将订阅者注册的消息推入到消息队列<br>        //2.参数:所以要传两个参数,消息类型和处理动作,<br>        //3.消息不存在重新创建,存在将消息推入到执行方法</p><pre><code>  regist:function(type,fn)&#123;    //如果消息不存在,创建    if(typeof _message[type]===&#39;undefined&#39;)&#123;      _message[type]=[fn];    &#125;else&#123;      //将消息推入到消息的执行动作      _message[type].push(fn);    &#125;  &#125;,  //发布信息接口    //1.作用:观察这发布消息将所有订阅的消息一次执行    //2.参数:消息类型和动作执行传递参数    //3.消息类型参数必须校验  fire:function(type,args)&#123;    //如果消息没有注册,则返回    if(!_message[type]) return;      //定义消息信息      var events=&#123;        type:type, //消息类型        args:args||&#123;&#125; //消息携带数据      &#125;,      i=0,      len=_message[type].length;      //遍历消息      for(;i&lt;len;i++)&#123;        //依次执行注册消息        _message[type][i].call(this,events);      &#125;  &#125;,  //移除信息接口    //1.作用:将订阅者注销消息从消息队列清除    //2.参数:消息类型和执行的动作    //3.消息参数校验  remove:function(type,fn)&#123;    //如果消息动作队列存在    if(_message[type] instanceof Array)&#123;      //从最后一个消息动作序遍历      var i=_message[type].length-1;      for(;i&gt;=0;i--)&#123;        //如果存在该动作在消息队列中移除        _message[type][i]===fn&amp;&amp;_message[type].splice(i,1);      &#125;    &#125;  &#125;&#125;</code></pre><p>  })()</p><p>//测试用例<br>  //1.订阅消息<br>  Observer.regist(‘test’,function(e){<br>    console.log(e.type,e.args.msg);<br>  })</p><p>  //2.发布消息<br>  Observer.fire(‘test’,{msg:’传递参数1’});<br>  Observer.fire(‘test’,{msg:’传递参数2’});<br>  Observer.fire(‘test’,{msg:’传递参数3’});<br>6.11状态模式<br>1.定义:一个对象状态改变会导致行为变化<br>2.作用:解决复杂的if判断<br>3.代码<br>状态模式</p><p>6.12策略模式<br>1.定义:定义了一系列家族算法，并对每一种算法单独封装起来，让算法之间可以相互替换，独立于使用算法的客户<br>2.代码<br>策略模式</p><p>6.13.访问模式<br>1.定义:通过继承封装一些该数据类型不具备的属性,<br>2.作用:让对象具备数组的操作方法<br>3.代码:<br>访问者模式</p><p>6.14中介者模式<br>1.定义:设置一个中间层,处理对象之间的交互<br>2.代码:<br>中介者模式</p><ol start="7"><li>HTTP<br>1.1 什么是 HTTP<br>HTTP 是一个连接客户端，网关和服务器的一个协议。</li></ol><p>7.2 特点<br>支持客户/服务器模式：可以连接客户端和服务端；<br>简单快速：请求只需传送请求方法，路径和请求主体；<br>灵活：传输数据类型灵活；<br>无连接：请求结束立即断开；<br>无状态：无法记住上一次请求。</p><p>7.3 怎么解决无状态和无连接<br>无状态：HTTP 协议本身无法解决这个状态，只有通过 cookie 和 session 将状态做贮存，常见的场景是登录状态保持；</p><p>无连接：可以通过自身属性 Keep-Alive。</p><p>7.4 请求过程<br>HTTP(S) 请求地址 → DNS 解析 → 三次握手 → 发送请求 → 四次挥手</p><p>三次握手过程（图片来源 CSDN）<br>3 次握手.jpg</p><p>在这里插入图片描述</p><p>四次挥手过程（图片来源 CSDN）<br>image</p><p>在这里插入图片描述</p><p>7.5 HTTP 0.9~3.0 对比<br>7.5.1 HTTP 0.9<br>只允许客户端发送 GET 这一种请求；<br>且不支持请求头，协议只支持纯文本；<br>无状态性，每个访问独立处理，完成断开；<br>无状态码。</p><p>7.5.2 HTTP 1.0<br>有身份认证，三次握手；<br>请求与响应支持头域；<br>请求头内容；</p><p>属性名    含义<br>Accept    可接受的 MIME 类型<br>Accept-Encoding    数据可解码的格式<br>Accept-Language    可接受语言<br>Connection    值 keep-alive 是长连接<br>Host    主机和端口<br>Pragma    是否缓存,指定 no-cache 返回刷新<br>Referer    页面路由<br>If-Modified-Since    值为时间<br>响应头内容；</p><p>属性名    含义<br>Connection    值 keep-alive 是长连接<br>Content-Type    返回文档类型,常见的值有 text/plain,text/html,text/json<br>Date    消息发送的时间<br>Server    服务器名字<br>Last-Modified    值为时间,s 返回的最后修改时间<br>Expires    缓存过期时间,b 和 s 时间做对比<br>注意</p><p>expires 是响应头内容，返回一个固定的时间,缺陷是时间到了服务器要重新设置。<br>请求头中如果有 If-Modified-Since，服务器会将时间与 last-modified 对比，相同返回 304。<br>响应对象以一个响应状态行开始<br>响应对象不只限于超文本<br>支持 GET、HEAD、POST 方法<br>有状态码<br>支持长连接（但默认还是使用短连接）、缓存机制以及身份认证。</p><p>7.5.3 HTTP 1.1<br>请求头增加 Cache-Control</p><p>属性名    含义<br>Cache-Control    在1.1 引入的方法,指定请求和响应遵循的缓存机制,值有:public(b 和 s 都缓存),private(b 缓存),no-cache(不缓存),no-store(不缓存),max-age(缓存时间,s 为单位),min-fresh(最小更新时间),max-age=3600<br>If-None-Match    上次请求响应头返回的 etag 值响应头增加 Cache-Control，表示所有的缓存机制是否可以缓存及哪种类型 etag 返回的哈希值,第二次请求头携带去和服务器值对比<br>注意</p><p>Cache-Control 的 max-age 返回是缓存的相对时间<br>Cache-Control 优先级比 expires 高<br>缺点：不能第一时间拿到最新修改文件</p><p>7.5.4 HTTP 2.0<br>采用二进制格式传输<br>多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞<br>报头压缩<br>服务器推送主动向 B 端发送静态资源，避免往返延迟。</p><p>7.5.5 HTTP 3.0<br>1.是基于 QUIC 协议，基于 UDP<br>2.特点:<br>自定义连接机制：TCP 以 IP/端口标识,变化重新连接握手，UDP 是一 64 位 ID 标识，是无连接；<br>自定义重传机制：TCP 使用序号和应答传输，QUIC 是使用递增序号传输； 无阻塞的多路复用：同一条 QUIC 可以创建多个 steam。</p><p>7.5.6 HTTPS<br>1.https 是在 http 协议的基础上加了个 SSL；<br>2.主要包括：握手(凭证交换和验证)和记录协议(数据进行加密)。</p><p>7.5.7 缓存<br>1.按协议分：协议层缓存和非 http 协议缓存：<br>1.1协议层缓存：利用 http 协议头属性值设置；<br>1.2非协议层缓存：利用 meta 标签的 http-equiv 属性值 Expires,set-cookie。</p><p>2.按缓存分：强缓存和协商缓存：<br>2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；<br>2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。</p><p>3.协商缓存对比： etag 优先级高于 last-modified；<br>4.etag 精度高，last-modified 精度是 s，1s 内 etag 修改多少次都会被记录； last-modified 性能好，etag 要得到 hash 值。</p><p>5.浏览器读取缓存流程：<br>会先判断强缓存；再判断协商缓存 etag(last-modified)是否存在；<br>存在利用属性 If-None-match(If-Modified-since)携带值；<br>请求服务器,服务器对比 etag(last-modified)，生效返回 304。</p><p>F5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效</p><p>7.5.8 状态码<br>序列    详情<br>1XX(通知)<br>2XX(成功)    200(成功)、201(服务器创建)、202(服务器接收未处理)、203(非授权信息)、204(未返回内容)、205(重置内容)、206(部分内容)<br>3XX(重定向)    301(永久移动)、302(临时移动)、303(查看其他位置)、304(未修改)、305(使用代理)、307(临时重定向)<br>4XX(客户端错误)    400(错误请求)、401(未授权)、403(禁止)、404(未找到)、405(方法禁用)、406(不接受)、407（需要代理授权）<br>5XX(服务器错误)    500(服务器异常)、501（尚未实施）、502（错误网关）、503（服务不可用）、504（网关超时）、505（HTTP 版本不受支持）<br>7.5.9 浏览器请求分析<br>在这里插入图片描述</p><p>7.5.10 总结<br>协议</p><p>版本    内容<br>http0.9    只允许客户端发送 GET 这一种请求;且不支持请求头,协议只支持纯文本;无状态性,每个访问独立处理,完成断开;无状态码<br>http1.0 解决 0.9 的缺点,增加 If-modify-since(last-modify)和 expires 缓存属性<br>http1.x    增加 cache-control 和 If-none-match(etag)缓存属性<br>http2.0    采用二进制格式传输;多路复用;报头压缩;服务器推送<br>http3.0    采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用<br>缓存</p><p>类型    特性<br>强缓存    通过 If-modify-since(last-modify)、expires 和 cache-control 设置，属性值是时间，所以在时间内不用请求<br>协商缓存    通过 If-none-match(etag)设置，etag 属性是哈希值，所以要请求和服务器值对比<br>8.总结<br>这只是 JS 原生梳理,后续会再出 react,node,小程序相关的梳理;<br>原创码字不易,欢迎 star!</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制ant.design表格组件教程</title>
      <link href="/zi-zhi-ant-design-biao-ge-zu-jian-jiao-cheng/"/>
      <url>/zi-zhi-ant-design-biao-ge-zu-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际项目中我们时常有可能需要Ip地址输入框，键值对输入框这样的复杂输入组件。但是<code>ant design</code><br>官方并没有给出这样的组件，文档中也没有提到应该如何写出这样的组件。</p><p>我在研究了一番实现了该功能，在这里与大家分享一下，希望可以方便到后来人。</p><h3 id="源码分享"><a href="#源码分享" class="headerlink" title="源码分享"></a>源码分享</h3><p>对于不需要教程的同学可以直接查看源码：</p><h3 id="教程-编写一个IP输入组件"><a href="#教程-编写一个IP输入组件" class="headerlink" title="教程-编写一个IP输入组件"></a>教程-编写一个IP输入组件</h3><h4 id="第一步：完全受控组件与ant-design表格组件联动"><a href="#第一步：完全受控组件与ant-design表格组件联动" class="headerlink" title="第一步：完全受控组件与ant design表格组件联动"></a>第一步：完全受控组件与ant design表格组件联动</h4><p>首先我们需要建立一个完全受控的输入组件，并且该组件可以嵌套进ant design的表格组件当中并正常<br>运行。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token entity" title="&#123;">&amp;#123;</span><span class="token function">getFieldDecorator</span><span class="token punctuation">(</span><span class="token string">'ip'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IpInput</span> <span class="token punctuation">/></span></span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p>IpInput组件代码：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token entity" title="&#123;">&amp;#123;</span>Component<span class="token entity" title="&#125;">&amp;#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token entity" title="&#123;">&amp;#123;</span>Input<span class="token entity" title="&#125;">&amp;#125;</span> <span class="token keyword">from</span> <span class="token string">"antd"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">IpInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token entity" title="&#123;">&amp;#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>      ip<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token entity" title="&#125;">&amp;#125;</span>  hdlInputChange <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span>ip<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onChange</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span>target<span class="token punctuation">:</span> <span class="token entity" title="&#123;">&amp;#123;</span>value<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>  <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Input</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span>&amp;#123;this.state.ip&amp;#125;</span> <span class="token attr-name">onChange</span><span class="token attr-value"><span class="token punctuation">=</span>&amp;#123;this.hdlInputChange&amp;#125;</span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p><a href="https://codesandbox.io/s/step1-ztch4?fontsize=14">在CodeSandbox中浏览</a></p><h4 id="第二步：在IpInput组件中建立多个Input，并联动"><a href="#第二步：在IpInput组件中建立多个Input，并联动" class="headerlink" title="第二步：在IpInput组件中建立多个Input，并联动"></a>第二步：在IpInput组件中建立多个Input，并联动</h4><p>重点是输出值的拆分与聚合</p><pre class=" language-javascript"><code class="language-javascript">hdlInputChange <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> block<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> ipAdressArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>ablock<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>bblock<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>cblock<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>dblock<span class="token punctuation">]</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token template-string"><span class="token string">`$&amp;#123;block&amp;#125;block`</span></span><span class="token punctuation">]</span><span class="token punctuation">:</span> value<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    ipAdressArr<span class="token punctuation">[</span>blockDict<span class="token punctuation">[</span>block<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> value    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onChange</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>target<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>value<span class="token punctuation">:</span> ipAdressArr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>详细代码请看：<a href="https://codesandbox.io/s/step2-b4huv?fontsize=14">CodeSandbox</a></p><p>到这一步一个基本的<code>ip Input</code>输入组件已经成型，但是难点部分还未开始。</p><h4 id="第三步：校验规则处理"><a href="#第三步：校验规则处理" class="headerlink" title="第三步：校验规则处理"></a>第三步：校验规则处理</h4><p>如果现在我们就开始正常使用该组件，4个输入框的报错样式必定是同时出现的。一个是红框的话，其他<br>三个也必定是红框状态。这是<code>ant design</code>的程序设计，<code>FormItem</code>的报错样式由外层容器通过CSS控制。</p><p>上面这段话不容易理解的话自己试一下就明白了。</p><p>也就是说我们需要单独控制4个Input框的校验状态，已经有数字的应为正确状态，没有数字的校验时显示为<br>红色。且这个校验行为要能够被<code>ant design</code>的<code>Form</code>组件触发。</p><p>首先我们建立一个类似<code>ant design</code>原生的<code>Form.Item</code>组件用来包裹每个<code>Input</code>并负责校验逻辑。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">FromItemValidatorWarpper</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token entity" title="&#123;">&amp;#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>      validateStatus<span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token entity" title="&#125;">&amp;#125;</span>  componentDidMount <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span>  componentDidUpdate <span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>valiating <span class="token operator">&amp;&amp;</span> prevProps<span class="token punctuation">.</span>validating <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>valiating<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>      <span class="token comment" spellcheck="true">// form 触发的 validating</span>      <span class="token keyword">let</span> validateStatus <span class="token operator">=</span> <span class="token string">''</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getChildProp</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>        validateStatus <span class="token operator">=</span> <span class="token string">'error'</span>      <span class="token entity" title="&#125;">&amp;#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>validateStatus <span class="token operator">!==</span> validateStatus<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span>validateStatus<span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>      <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token function">getChildProp</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children    <span class="token keyword">return</span> child <span class="token operator">&amp;&amp;</span> child<span class="token punctuation">.</span>props <span class="token operator">&amp;&amp;</span> child<span class="token punctuation">.</span>props<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Form.Item</span>        <span class="token attr-name">validateStatus</span><span class="token attr-value"><span class="token punctuation">=</span>&amp;#123;this.state.validateStatus&amp;#125;</span>      <span class="token punctuation">></span></span>        <span class="token entity" title="&#123;">&amp;#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token entity" title="&#125;">&amp;#125;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Form.Item</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span>  <span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p>然后用该组件包裹<code>IpInput</code>组件</p><pre class=" language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FromItemValidatorWarpper</span> <span class="token attr-name">valiating</span><span class="token attr-value"><span class="token punctuation">=</span>&amp;#123;this.state.valiating&amp;#125;</span><span class="token punctuation">></span></span>  <span class="token operator">&lt;</span>Input value<span class="token operator">=</span><span class="token entity" title="&#123;">&amp;#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>dblock<span class="token entity" title="&#125;">&amp;#125;</span> onChange<span class="token operator">=</span><span class="token entity" title="&#123;">&amp;#123;</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token entity" title="&#123;">&amp;#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hdlInputChange</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span> <span class="token operator">/</span><span class="token operator">></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FromItemValidatorWarpper</span><span class="token punctuation">></span></span></code></pre><p>在<code>IpInput</code>组件中建立<code>valiating</code>属性，并使其和外层<code>ant design Form</code>组件的<code>validator</code>联动。</p><pre class=" language-jsx"><code class="language-jsx">  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">let</span> dataField <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">[</span><span class="token string">"data-__field"</span><span class="token punctuation">]</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dataField<span class="token punctuation">.</span>errors <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>prevProps<span class="token punctuation">[</span><span class="token string">"data-__field"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>errors<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>      <span class="token comment" spellcheck="true">// valitor 函数触发报错</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span>valiating<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>    <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>dataField<span class="token punctuation">.</span>errors <span class="token operator">&amp;&amp;</span> prevProps<span class="token punctuation">[</span><span class="token string">"data-__field"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>errors<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>      <span class="token comment" spellcheck="true">// valitor 函数触发清除报错</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span>valiating<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>    <span class="token entity" title="&#125;">&amp;#125;</span>  <span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p>最后在使用<code>IpInput</code>的组件位置添加一个正则校验。</p><pre class=" language-jsx"><code class="language-jsx">  <span class="token entity" title="&#123;">&amp;#123;</span><span class="token function">getFieldDecorator</span><span class="token punctuation">(</span><span class="token string">'ip'</span><span class="token punctuation">,</span> <span class="token entity" title="&#123;">&amp;#123;</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token entity" title="&#123;">&amp;#123;</span>required<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token string">'Please input your ip!'</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>      <span class="token entity" title="&#123;">&amp;#123;</span>        pattern<span class="token punctuation">:</span> <span class="token regex">/((?:(?:25[0-5]|2[0-4]\d|((1\d&amp;#123;2&amp;#125;)|([1-9]?\d)))\.)&amp;#123;3&amp;#125;(?:25[0-5]|2[0-4]\d|((1\d&amp;#123;2&amp;#125;)|([1-9]?\d))))/</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'Please finish your ip!'</span>      <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IpInput</span><span class="token punctuation">/></span></span>  <span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p><a href="https://codesandbox.io/s/step3-us20k?fontsize=14">请在CodeSandbox中查看效果</a></p><p>OK，我们现在只差最后一步了，即在外层使用组件时使用<code>setFieldsValue</code>初始化组件值的功能。</p><h4 id="第四步：setFieldsValue方法支持"><a href="#第四步：setFieldsValue方法支持" class="headerlink" title="第四步：setFieldsValue方法支持"></a>第四步：<code>setFieldsValue</code>方法支持</h4><p><code>componentDidUpdate</code>方法中加入一段代码判断组件上级value是否和内部value相同，不同且没有进行<br>初始化时进行初始化。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">if</span><span class="token punctuation">(</span>dataField<span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>ablock<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>bblock<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>cblock<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>dblock<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>initialized<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>initialized <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token keyword">let</span> ipAdressArr <span class="token operator">=</span> dataField<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span>    ablock<span class="token punctuation">:</span> ipAdressArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    bblock<span class="token punctuation">:</span> ipAdressArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    cblock<span class="token punctuation">:</span> ipAdressArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    dblock<span class="token punctuation">:</span> ipAdressArr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p><a href="https://codesandbox.io/s/step4-l5jht?fontsize=14">请在CodeSandbox中查看效果</a></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上，一个IP输入组件基本完成了。细节包括样式还有很多可以优化的地方，我在这里就不继续了。maybe<br>以后再来更新。</p><p>我把最后的完整代码放在<a href="https://github.com/mikexfreeze/custom-antd-form">github</a>上,有任何建议可<br>以给我提交issue或下面评论回复，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
            <tag> ant design </tag>
            
            <tag> antd </tag>
            
            <tag> 自定义组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联通G2-40盒子刷机教程</title>
      <link href="/lian-tong-g2-40-he-zi-shua-ji-jiao-cheng/"/>
      <url>/lian-tong-g2-40-he-zi-shua-ji-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步-下载刷机包"><a href="#第一步-下载刷机包" class="headerlink" title="第一步 下载刷机包"></a>第一步 下载刷机包</h2><p>链接: <a href="https://pan.baidu.com/s/1SsFGpNPtKsXQvbpBZLiDRw">百度云</a> 提取码: um8d</p><h2 id="第二步-准备刷机U盘"><a href="#第二步-准备刷机U盘" class="headerlink" title="第二步 准备刷机U盘"></a>第二步 准备刷机U盘</h2><ol><li>U盘格式化为FAT32格式</li><li>解压下载的刷机包，将解压内容复制到U盘根目录</li></ol><img src="/lian-tong-g2-40-he-zi-shua-ji-jiao-cheng/U%E7%9B%98%E6%96%87%E4%BB%B6.jpg" class="" title="U盘包含文件"><h2 id="第三部-拆机"><a href="#第三部-拆机" class="headerlink" title="第三部 拆机"></a>第三部 拆机</h2><ol><li>卸下底部的4颗螺丝，卸下顶部面板</li><li><p>短接J38跳线</p><blockquote><p>我使用的是一根回形针，见下图，任何导电的物体皆可。</p></blockquote></li><li><p>插入U盘</p></li></ol><img src="/lian-tong-g2-40-he-zi-shua-ji-jiao-cheng/%E8%B7%B3%E7%BA%BF.jpg" class="" title="跳线位置如图所示"><h2 id="第四部-通电开始刷机"><a href="#第四部-通电开始刷机" class="headerlink" title="第四部 通电开始刷机"></a>第四部 通电开始刷机</h2><ol><li>连接HDMI线，电源线开始刷机</li><li>电视出现如下画面说明刷机开始，此时可以拔出跳线，如果到进度条走完还不拔，机器重启之后又会开始刷机。</li></ol><img src="/lian-tong-g2-40-he-zi-shua-ji-jiao-cheng/%E5%88%B7%E6%9C%BA%E7%94%BB%E9%9D%A2.jpg" class="" title="刷机画面"><ol start="3"><li>等待进度条走完并重启自动进入新系统，至此刷机完成。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>整个过程还是比较简单的，刷机之后的新系统使用起来感觉也很不错。个人感觉要强于小米。<br>真是废物利用的好rom，感谢作者。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新西伯利亚市《开拓月球和火星》</title>
      <link href="/xin-xi-bo-li-ya-shi-kai-tuo-yue-qiu-he-huo-xing/"/>
      <url>/xin-xi-bo-li-ya-shi-kai-tuo-yue-qiu-he-huo-xing/</url>
      
        <content type="html"><![CDATA[<p>偶然之间看到这条新闻，50年前的苏联朋友们对50年后的畅想。</p><blockquote><p>新西伯利亚市《开拓月球和火星》亲爱的后代，今天是苏联建国100周年（苏联的国庆日是“十月革命”纪念日当天）的特别的日子。热烈祝贺这伟大而光荣的纪念日。我们的时代是很有趣的，想必你们的时代也很有趣吧。我们现在还在建设共产主义，你们应该已经生活在共产主义中了吧。我们相信，你们已经漂亮地开发了我们的美丽的蓝色行星，开拓月球，在火星着陆，不断地向着宇宙进发。太空船是不是已经冲出了银河系了呢？是不是已经和其他行星文明的代表们进行了对科学和文化合作的交涉了呢。”</p></blockquote><blockquote><p>摩尔曼斯克市《发现了很多自然的新的秘密》我们才刚刚向着宇宙踏出第一步，但是你们应该已经可以飞往其他行星了吧。很多现在还没发现的自然的新的秘密已经被发现了吧，核能可以控制了吧，元素的量可以根据人类意愿控制了吧，气候已经可以改变了吧，在北极可以开发花园了吧。希望1917年燃起的列宁永恒思想之火，能够永远在你们的心中燃烧。万岁！”</p></blockquote><blockquote><p>阿迪格共和国迈科普地区《21世纪是共产主义胜利的世纪！》“沙俄时代是一片荒芜、无法地带的阿迪格，现在已经变成了有着先进的社会主义经济、工业，高识字率、高文化程度的地方。在下一个即将到来的50周年，我相信，进步的人类已经面对所有民族的不共戴天之敌——帝国主义——取得了决定性的胜利。在马克思列宁主义的武装下，在科学预见力量的指引下，我们知道共产主义就会建立起来。愿21世纪是共产主义席卷全球、凯旋的世纪！”</p></blockquote><p>短短的三段文字，看完之后心中却充满了唏嘘。为何50年后的我们没有达到他们的期待。为何曾经的超级大国，如今已经沦落到要靠卖资源度日。</p><p>但是我想，50年抑或500年其实都不是问题，只要人类还在向前，跨越星辰大海所需要的时间对个人来说也许很长，对宇宙来说都只是弹指一挥间。</p><iframe src="https://v.qq.com/txp/iframe/player.html?vid=b05037uapwj" width="100%" height="500" frameborder="0" loading="lazy" allowfullscreen></iframe><img src="/xin-xi-bo-li-ya-shi-kai-tuo-yue-qiu-he-huo-xing/20171112163017682.jpeg" class=""><p><a href="https://www.zhihu.com/question/341935042/answer/800236763">为什么文明才5000年 而地球都46亿岁了。从自然正态分布规律来讲，我们这代人是不是运气太差了？ - 周启楠的回答 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/31083053">苏联2017——时空胶囊中的未来展望</a></p><p><a href="https://www.guancha.cn/Neighbors/2017_11_12_434534.shtml">50年前的这五封信，来自苏联1967年封藏的时间胶囊</a></p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grafana调研和Superset对比</title>
      <link href="/grafana-diao-yan-he-superset-dui-bi/"/>
      <url>/grafana-diao-yan-he-superset-dui-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="Grafana调研"><a href="#Grafana调研" class="headerlink" title="Grafana调研"></a>Grafana调研</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用Docker安装</p><p><strong>注意事项：</strong></p><ol><li>启动时需要设置数据库，否则Grafana会使用嵌入式数据库sqlite3。</li></ol><h3 id="支持图表"><a href="#支持图表" class="headerlink" title="支持图表"></a>支持图表</h3><p><a href="https://grafana.com/docs/features/panels/graph/">官方文档</a>，只有四种类型分别为Graph,Singlestat,Table,Heatmap</p><h3 id="项目引入"><a href="#项目引入" class="headerlink" title="项目引入"></a>项目引入</h3><p>方式一：Dashboard snapshot</p><p> 分享整个Dashboard，不需要额外的权限设置。</p><p>方式二：Share Panel-Embed Panel</p><p> 设置<code>AUTH_ANONYMOUS_ENABLED</code>为<code>true</code>允许<code>anonymous</code>访问。即可单独分享每一个<code>graph panel</code>。</p><h3 id="Dashboard市场"><a href="#Dashboard市场" class="headerlink" title="Dashboard市场"></a>Dashboard市场</h3><p>Grafana有把Dashboard配置通过JSON文件导入/导出功能，同时官方建立了一个在线的市场，方便大家交流。但是因为数据源的差异性，实际用途不大。</p><p>目前市场是下载比较的多的配置，是一些基于通用数据源的配置。例如<a href="https://prometheus.io/">prometheus</a>，实际上Prometheus也把Grafana当作自己的图形解决方案。</p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p> Grafana提供了通过插件扩展控能，例如安装饼图插件支持饼图设置，安装数据源插件增加支持的数据源。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>进行中</p><h3 id="MongoDB连接"><a href="#MongoDB连接" class="headerlink" title="MongoDB连接"></a>MongoDB连接</h3><p>待测试，MongoDB connect BI插件理论上可行</p><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><p>Grafana star 29.2k+ 有企业版（收费）<a href="https://play.grafana.org/d/000000012/grafana-play-home?orgId=1">Live Demo</a></p><p>Superset star 24.7k+</p><p><strong>开源许可证都为apache-2.0</strong></p><p>Superset</p><blockquote><p><strong>优点：</strong><br>采用D3图表库初始支持的图表类型就十分丰富</p></blockquote><p>Grafana</p><blockquote><p><strong>优点：</strong>  </p><pre><code>1. 支持插件方便社区为其提供扩展能力  2. 项目引入简单，不需要二次开发</code></pre></blockquote><h3 id="总结-amp-建议"><a href="#总结-amp-建议" class="headerlink" title="总结&amp;建议"></a>总结&amp;建议</h3><p>经过初步的了解，我的建议是使用Grafana。原因有以下几点：</p><ol><li>目前的流行程度Grafana略微占优，正在使用的企业数量似乎更多（superset没有找到相关数据）。</li><li>Grafana有独立的公司在开发维护，并且同时就在提供商业服务。商业成熟度上远远领先Superset。</li><li>Grafana的插件设计模式更加优秀，方便社区提供能量。</li></ol><p>Grafana的潜在缺点：</p><p>没有选择类似D3的库作为图形上的支持，我觉得有长期的运营打算在其中，也许是在为今后的按图表插件来收费的模式做准备。这样的模式没什么不好，但是长期来看通过自研要做出和D3同样水平的图表库需要很长的时间，最终能否达到同样的水平很难说。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csv文件通过node.js转存postresql数据库</title>
      <link href="/csv-wen-jian-tong-guo-node-js-zhuan-cun-postresql-shu-ju-ku/"/>
      <url>/csv-wen-jian-tong-guo-node-js-zhuan-cun-postresql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h3 id="排坑"><a href="#排坑" class="headerlink" title="排坑"></a>排坑</h3><p>分享一下代码</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../config'</span><span class="token punctuation">)</span><span class="token keyword">const</span> pglink <span class="token operator">=</span> config<span class="token punctuation">.</span>pg<span class="token keyword">const</span> csv <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'csvtojson'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>Client<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'pg'</span><span class="token punctuation">)</span><span class="token keyword">const</span> copyFrom <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'pg-copy-streams'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">from</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">(</span>targetTable<span class="token punctuation">,</span> inputFile<span class="token punctuation">,</span> columnStr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'开始导入'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Connecting to Database</span>  <span class="token keyword">const</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    connectionString<span class="token punctuation">:</span> pglink<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">var</span> stream <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token function">copyFrom</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`COPY $&amp;#123;targetTable&amp;#125; ($&amp;#123;columnStr&amp;#125;) FROM STDIN CSV`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> fileStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span>  fileStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Error in creating read stream $&amp;#123;error&amp;#125;`</span></span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  stream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Error in creating stream $&amp;#123;error&amp;#125;`</span></span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  stream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Completed loading data into $&amp;#123;targetTable&amp;#125;`</span></span><span class="token punctuation">)</span>    client<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  fileStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>调用代码示例</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> copyToPg <span class="token operator">=</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'/* 上面的代码 */'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">const</span> inputFile <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'/csv/country.csv'</span><span class="token punctuation">)</span><span class="token function">copyToPg</span><span class="token punctuation">(</span><span class="token string">'Country'</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'/csv/country.csv'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'country, code, continent'</span><span class="token punctuation">)</span></code></pre><p>这里有两个坑需要特别说明<code>targetTable</code>这里是区分大小写的，而且只支持小写。。。</p><p>CSV需要使用utf8格式，不然会有中文乱码问题。但是你使用Excel是改不了utf8的，我的操作流程是使用记事本打开csv文件再改变编码转存。<br>之后再使用Excel编辑。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.postgresql.org/docs/9.3/sql-copy.html">官方说明档：sql-copy</a></p><p><a href="https://medium.com/@sairamkrish/how-to-do-postgresql-bulk-insert-with-node-pg-copy-streams-f4301ec29388">How to do postgresql bulk insert with node-pg-copy-streams</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买不起airPods怎么办？</title>
      <link href="/mai-bu-qi-airpods-zen-me-ban/"/>
      <url>/mai-bu-qi-airpods-zen-me-ban/</url>
      
        <content type="html"><![CDATA[<h3 id="redmi-airdots-你值得拥有"><a href="#redmi-airdots-你值得拥有" class="headerlink" title="redmi airdots 你值得拥有"></a>redmi airdots 你值得拥有</h3><p>先看下特性参数蓝牙5.0，单耳机重量4.1g，7.2mm动圈，分体式。基本上蓝牙5.0分体式其他品牌找不到200块以下，估计300块以下都很难。<br>100￥基本屌全场。</p><p>在100-1200这个价位区间里面，我基本找不到能在性价比上挑战airdots的产品。总之如果你想要买一副轻巧的入耳式蓝牙耳机，又觉得<br>airPods太贵的话，目前redmi airdots可说是不二选择。</p><p>— 下面开始讲故事，长文预警 —</p><p>从去年7月我换了小米8开始，蓝牙耳机成了一个硬性需求。type-c转3.5mm方案实在太二，本身一条线就已经够麻烦，中间再接一条简直崩溃。<br>而且从我粗浅的耳机知识上来理解，type-c转3.5mm中间多经历了一次数字转模拟的过程肯定会降低音质（不知道这个理解对不对欢迎大神<br>拍砖）。</p><p>当时我就对蓝牙耳机市场进行了一次调研。得出的结论是目前不适合购入高档的蓝牙耳机，airPods除外，如果airPods算高档的话。PS：在我的<br>心目中是不算的。没有音质谈什么高档。</p><p>原因主要在于目前蓝牙技术的不成熟当时市面上还是4.0的天下，虽然现在到了5.0离达到人能分辨的完美音质仍有一定差距。5.0由4.0的1Mbps<br>提升到2Mbps，也就是200kps的瞬时速率。下载过mp3的同学应该知道320kps只能算是比较高而已。（这里也完全是我的个人认为，实际上我<br>不确定kps是否等同于kbs）总之蓝牙要想达到媲美模拟信号的音质目前还差的很远。在目前的蓝牙设备上谈音质无异于耍流氓。</p><p>既然两千块的蓝牙耳机也就是听个响，我更倾向于价格便宜音质不太差的解决方案。目前几百块的耳机市场可说是群雄逐鹿一片混乱，其中<br>又充斥各种同质化严重的贴牌产品，基本同一个模具换个logo就能有N种不同的蓝牙耳机诞生。有兴趣的朋友可以看看TESTV的测评视频<br><a href="https://www.bilibili.com/video/av41982410/">平价真无线耳机们到底好用不好用【值不值得买第307期】</a>，基本说的就是这个情况。</p><p>所以去年我购入了漫步者W200BT的网易特供版W280X<br><img src="/mai-bu-qi-airpods-zen-me-ban/w280x.jpg" class="" title="W280X"></p><p>由于不是分体式耳机听诊器效应不可避免。可以同时连接两个设备，这是个非常鸡肋的功能和airpods的丝般顺滑相比完全是另一个极端。<br>同时连接两个设备之后信号稳定度大大下降，音质也收到了影响。红米airdots一次只能连接一台设备的估计就是因为这个原因。通话效果<br>十分之差，对方经常听不清你在说啥。电池续航还行连续听歌可以支持6小时左右。充电方式十分丑陋，你需要抠开一个胶垫保护的充电接口<br>再插上充电线。充电线和耳机线必成一个直角，放哪都碍事，智障设计。</p><p>音质，肯定是不存在音质的。可以感觉到调教上特地强调了低音，但是不知是动圈不够大，还是驱动不行，给人一种嗓子哑了吼不上去沉不下来<br>的感觉，总之就是灾难。</p><p>在使用w280x的期间也试用过airpods，感觉就是一分钱一分货。在苹果系的产品间切换丝般顺滑，充电，取耳机，配对整个使用流程都充满了<br>高级感。在苹果手机上的动画都是如此炫酷。你只能惊讶于三年了，市场上仍然没有一款能与其全方位竞争的产品。就连苹果自己唯一能做<br>的升级也就是提升下连接速度增加siri的语音唤醒。虽然这个技术上屌到不行的语音唤醒黑科技你几乎不会用。</p><img src="/mai-bu-qi-airpods-zen-me-ban/airpods.jpg" class="" title="airpods"><p>总之你有钱就买苹果，买不了吃亏买不了上当。使用过程中我发现一个场景是绝对只有airpods能做到的。就是你带着耳机躺床上还能侧头靠<br>在枕头上。换市面上任何一种其他耳机都是绝对不可能的，不把你杠死才怪。</p><p>最后来说说红米airdots</p><img src="/mai-bu-qi-airpods-zen-me-ban/airdots.jpg" class="" title="airdots"><p>缺点：设备间切换很不方便，必须先断连再连接新设备。从手机切电脑，你得先在手机上操作断连，再在电脑上操作连接。傻X设计，应了<br>雷总的话，没有设计就是没有设计（误）。</p><p>音质，跟airpods一样白开水，没有针对低音的增强。两者音质差不多同一级别。airdots因为有胶套的关系隔音效果更好，适合上下班的通勤<br>使用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一百块你买不了吃亏买不了上当。缺蓝牙耳机且缺钱的朋友可以毫不犹豫的购入。能不能买的到就是另外一个问题了。</p><p>至于发售一两个月还在缺货这个问题只能归结为在耍猴绝对没有别的解释。手机你可以说是高通不给力，或是你跟索尼关系不够好。耳机这种<br>完全没有核心科技的东西还特么缺货，在工业第一大国还要跟我说产能不足完全就是扯淡。</p><p>所以最近我对小米的观感是越来越差，快要差到锤子那个级别了。但，是人就逃不过真相定律。购买渠道一、淘宝加价20，二、官网京东抢，<br>抢的到算我输。三、如果你所在城市有小米之家可以去门店交钱预定，我运气好头一天交钱第二天到货。</p><p>以上，感谢您的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 随便韶韶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便韶韶 </tag>
            
            <tag> 测评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax接口接收文件排坑（二）</title>
      <link href="/ajax-jie-kou-jie-shou-wen-jian-pai-keng-er/"/>
      <url>/ajax-jie-kou-jie-shou-wen-jian-pai-keng-er/</url>
      
        <content type="html"><![CDATA[<h3 id="错误处理问题"><a href="#错误处理问题" class="headerlink" title="错误处理问题"></a>错误处理问题</h3><p>假设后端传回了一段包含错误message字段的JSON文件，如果将responseType 设置为 blob 将会导致无法解析后端传回的错误数据。</p><p>解决方案是将responseType 设置为 arraybuffer，根据http状态码来判断接口是否报错。假设接口返回400则将返回数据由arraybuffer<br>重新解析为String 或 Object 等我们需要的数据类型。</p><p>解析代码如下</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">errorCallback</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> encodedString <span class="token operator">=</span> String<span class="token punctuation">.</span>fromCharCode<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> decodedString <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token function">escape</span><span class="token punctuation">(</span>encodedString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> obj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>decodedString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>其中 <code>var decodedString = decodeURIComponent(escape(encodedString));</code>这段代码的作用是解析utf8字符。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://stackoverflow.com/questions/17191945/conversion-between-utf-8-arraybuffer-and-string">Conversion between UTF-8 ArrayBuffer and String</a></p><p><a href="https://stackoverflow.com/questions/30052567/how-to-read-json-error-response-from-http-if-responsetype-is-arraybuffer">How to read JSON error response from $http if responseType is arraybuffer</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁能真正make American greate again？</title>
      <link href="/shui-neng-zhen-zheng-make-american-greate-again/"/>
      <url>/shui-neng-zhen-zheng-make-american-greate-again/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Andrew-Yang.png" alt=""></p><p>今天第一次知道杨安泽(Andrew Yang)，美籍华裔祖籍台湾正在准备参加2020年美国总统大选。政治主张中主要的一条是要给<strong>每个满18周岁的美国人每月发1000美元</strong>。</p><h3 id="为什么，以及如何做到"><a href="#为什么，以及如何做到" class="headerlink" title="为什么，以及如何做到"></a>为什么，以及如何做到</h3><p>基础职工的失业不可避免现在的工业自动化是如此，未来的人工智能更是如此。川普试图从中国等其他国家夺回工作岗位思路本身就是错误的，真正夺走美国人工作的是技术革新。</p><p>那么谁在这场技术革新中获利了呢，是Amazon（他好像只举了这一个例子，耐人寻味）之类的高科技大企业。实施办法就是向这些企业征收高额税收，把这些钱分给所有美国人。劫富济贫（🙄socialism）？</p><p>公民收入增加之后，反过来可以增加消费促进经济发展，企业挣更多的钱，交更多的税，形成正向循环。</p><p>这位老兄的这方面的政治主张和我所想的完全一致。我甚至认为，未来人类在发明出强人工智能之后这是让人类社会可以延续下去的唯一政策。communism or die 二选一的命题。在强人工智能时代99%的人口对于社会生产力来说都会成为非必要人口，为了维持社会稳定共产主义可说是唯一的选项。</p><p>总之看到这位老哥及他的政治主张之后感慨颇多，感叹优秀的人都去了美国，感叹美国的制度给了很多人发声和表现得舞台。但作为一个生活在大洋彼岸得中国人，希不希望他成功当选真的不好说。感情上十分复杂。</p><p>但如果 Democracy 真得管用得话， American folks show me！</p><p><a href="https://www.youtube.com/watch?v=CvHyoQebbKU">FOX采访</a></p><p><a href="https://www.youtube.com/watch?v=l9RNdvtuAfA">CNN采访</a></p><p><a href="https://zhuanlan.zhihu.com/p/63516977">知乎：这位华裔总统候选人 要给每人每月发1000美元</a></p>]]></content>
      
      
      <categories>
          
          <category> 妄人妄语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政治 </tag>
            
            <tag> 美国 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax接口接收文件排坑(一)</title>
      <link href="/ajax-jie-kou-jie-shou-wen-jian-pai-keng/"/>
      <url>/ajax-jie-kou-jie-shou-wen-jian-pai-keng/</url>
      
        <content type="html"><![CDATA[<h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><p>如果你在用ajax接口接收文件时遇到文件保存后打开报错的情况，请尝试在请求header头中加入<code>responseType: arraybuffer</code></p><h3 id="排坑过程"><a href="#排坑过程" class="headerlink" title="排坑过程"></a>排坑过程</h3><p>最近在对接前后端文件传输接口时遇到的问题，后端返回xlsx文件，前端使用<code>new blob()</code>方法从接口返回的数据中重新生成文件。但是<br>生成的文件用excel打开总是报错。尝试在浏览器或Postman中调用接口保存文件都没有问题。</p><p>一开始各种尝试改变<code>new blob</code>方法的type参数没有效果。查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">blob方法文档</a>，<br>最坑的就是这里<code>Blob(blobParts[, options])</code>blobParts what fuck is blobParts? 文档中给出的示例有<br><code>new Blob([JSON.stringify(debug, null, 2),&#123;type : &#39;application/json&#39;&#125;);</code>so 一个包含字符串的数组？还有一段从blob中读取数据<br><code>reader.readAsArrayBuffer(blob);</code>可以看出这里读出的数据应该是arraybuffer。</p><p>再看一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType">XMLHttp​Request​.response​Type的官方文档</a><br>arraybuffer的解释 <em>是一个包含二进制数据的 JavaScript ArrayBuffer 。</em>另外我在另一篇<a href="https://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript">Creating a Blob from a base64 string in JavaScript</a><br>的提问中当中看到有高手给出的答案中指出了，想要得到blob你先要得到<em>ArrayBuffer, text, and JSON</em></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到这里我们基本已经得到答案了，生成blob对象进而生成文件我们需要ArrayBuffer, text, or JSON这种三种数据类型的某一种。</p><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>后端Java，代码当中使用的是 <code>BufferedOutputStream</code> 类来返回数据。前端分别测试了”json””text”””arraybutter””blob”四种responseType<br>arraybutter和blob都可以正确的生成文件。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType">MDN解释</a><br><a href="http://www.cnblogs.com/skywang12345/p/io_12.html">java io系列12之 BufferedInputStream(缓冲输入流)的认知、源码和示例</a><br><a href="https://blog.csdn.net/wkyseo/article/details/78232485">深入理解xhr的responseType中blob和arrayBuffer</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
            <tag> ajax </tag>
            
            <tag> responseType </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Superset学习之连接MongoDB</title>
      <link href="/superset-xue-xi-zhi-lian-jie-mongodb/"/>
      <url>/superset-xue-xi-zhi-lian-jie-mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="集成-MongoDB"><a href="#集成-MongoDB" class="headerlink" title="集成 MongoDB"></a>集成 MongoDB</h1><h5 id="方法一：mongodb-BI，已验证"><a href="#方法一：mongodb-BI，已验证" class="headerlink" title="方法一：mongodb-BI，已验证"></a>方法一：<a href="https://www.mongodb.com/products/bi-connector">mongodb-BI</a>，已验证</h5><p>MongoDB需要安装mongdoDB BI-connector 插件，该插件的功能是使mongoDB支持Sql查询语句，从而应对各种BI工具的连接，<a href="https://docs.mongodb.com/bi-connector/current/client-applications/">官方文档</a>中列举了其支持的各种BI工具。Superset不在官方支持列表当中，当然官方支持BI工具当中也没有类似Superset这种开源的PAAS类工具。<br>为了连通Superset，Superset侧也需要一个插件<a href="https://pypi.org/project/sqlalchemy-mongobi/">sqlalchemy-mongobi</a>（PS:该插件是收费的）。</p><h3 id="其他可能的实现方法"><a href="#其他可能的实现方法" class="headerlink" title="其他可能的实现方法"></a>其他可能的实现方法</h3><h5 id="方法二：转mongoDB至关系型数据库，举例mosql"><a href="#方法二：转mongoDB至关系型数据库，举例mosql" class="headerlink" title="方法二：转mongoDB至关系型数据库，举例mosql"></a>方法二：转mongoDB至关系型数据库，举例<a href="https://github.com/stripe/mosql">mosql</a></h5><h5 id="方法三：使用第三方的数据平台服务，举例dremio"><a href="#方法三：使用第三方的数据平台服务，举例dremio" class="headerlink" title="方法三：使用第三方的数据平台服务，举例dremio"></a>方法三：使用第三方的数据平台服务，举例<a href="https://www.dremio.com/">dremio</a></h5><p>总结，Superset等其他BI工具基本支持的都是Sql且关系型数据库，在配置数据图表时实际就是在组织Sql语句。所以非关系型数据库整合BI的问题基本归结为如何让其支持Sql语句。</p><h3 id="横向对比其他PAAS类BI"><a href="#横向对比其他PAAS类BI" class="headerlink" title="横向对比其他PAAS类BI"></a>横向对比其他PAAS类BI</h3><p>Grafana  star 27k+ 有企业版（收费）Live Demo</p><p>Superset  star 23k+</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Superset学习体验</title>
      <link href="/superset-xue-xi-ti-yan/"/>
      <url>/superset-xue-xi-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="superset代码评测"><a href="#superset代码评测" class="headerlink" title="superset代码评测:"></a>superset代码评测:</h1><p>版本还未稳定，release版本长时间脱离 master版本，且本身并不稳定。项目庞大涉及领域繁多加上人员混杂可能是导致目前代码略显凌乱bug较多的原因。尝试了几个不同的版本才获得一个可以在Ubuntu及Mac平台都可使用Docker正常运行的版本（非release版本），且该版本在前端控制台还存在肉眼可见的bug。版本号：(#6934) ea9d22b2eca6cf823380adc96d2040a5c955edd8</p><p>值得一提的问题，部署。项目的打包过程非常复杂，涉及到Linux的环境包，Python包，JavaScript包以及可能存在的其他未知类型的包。打包过程中GFW造成了巨大的阻碍。在有透明代理的路由环境下打包的成功率还是很高的，但在一般环境下成功率十不存一。甚至可能出现已经正常启动过的开发环境，重新启动时因为DNS污染的问题，把原来正确的包给破坏掉的情况。</p><p>可行的解决办法是在发布时进行本地打包Docker image，再上传至服务器启动，需要修改部分代码。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 虚拟机 Ubuntu 踩坑</title>
      <link href="/virtualbox-xu-ni-ji-ubuntu-cai-keng/"/>
      <url>/virtualbox-xu-ni-ji-ubuntu-cai-keng/</url>
      
        <content type="html"><![CDATA[<h3 id="虚拟机-网络设置"><a href="#虚拟机-网络设置" class="headerlink" title="虚拟机-网络设置"></a>虚拟机-网络设置</h3><ol><li>使用网络桥接模式保证host和虚拟机可以互访，虚拟机可连接Internet。</li><li>host系统下网卡设置共享</li><li>subnet <a href="http://www.subnet-calculator.com/subnet.php?net_class=B">地址计算器</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 学习记录</title>
      <link href="/docker-xue-xi-ji-lu/"/>
      <url>/docker-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h3><p>context build image build container run by daemon</p><p>docker-compose 为单独安装的软件，mac/windows 安装包自带，Linux自行安装</p><p>docker-machine 理解不深入，windows10非企业版下是控制虚拟机，win10非专业、企业版缺少Hyber-V支持，无法安装docker 安装包最新版，只能安装legacy版本。</p><h3 id="文件解释"><a href="#文件解释" class="headerlink" title="文件解释"></a>文件解释</h3><ol><li>Dockerfile用于build image</li><li>docker-compose.yml用于组织container，设置network，启动顺序，依赖关系，来源build或pull。</li></ol><h3 id="待补充知识"><a href="#待补充知识" class="headerlink" title="待补充知识"></a>待补充知识</h3><ol><li>container 内部操作及commit为新 image</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hooks 学习体会</title>
      <link href="/react-hooks/"/>
      <url>/react-hooks/</url>
      
        <content type="html"><![CDATA[<p>上接<a href="/2018/09/30/React、Vue比较/">React、Vue比较</a></p><p>又经过一段时间的学习和开发对React有了更加深刻的理解，领悟了相较于Vue更多的优势。应为语法更接近原生的关系，class在使用extends时很方便，可以把很多相近的页面组件的共通部分写成一个class专门用于继承，可以大大缩短开发时间。而这点在Vue上也有对应的实现mixin，但可惜的是官方文档几乎没有说明，也不清楚具体的内在机制。</p><p>还有最近的两个重磅更新懒加载的官方实现React.lazy + suspense 实现。以及react-hooks</p><p>react hooks 的实际效果让我想起了 meteor 中的动态变量，动态变量本身不依赖组件存在，而且始终具备动态属性。可以用专门的订阅器 watch 其变化。</p><p>当然区别还是很大的，hooks的设计初衷不是方便我们在组件之间传递它的。</p><p>我对官方介绍视频hooks的开发者Dan的最后一段话特别有感触。原文大意：React的logo是一个原子，似乎是想表达React对web开发的解构，万物由原子构成，而一个web项目则是由无数个组件构成。组件即是web的原子。就像科学家原先以为原子就是世间的最小单位，之后又发现了电子、中子。hooks即是React的电子，只是之前我们对其的理解不够深，看到是state、life-cycle之类的表象，剥去表象之后才发现其真实的样子，以及其是如何影响原子的特性的。看看react logo上那围绕中子的轨道，也许那就是hooks。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朋友该卖房了</title>
      <link href="/peng-you-gai-mai-fang-liao/"/>
      <url>/peng-you-gai-mai-fang-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="为何会有此文"><a href="#为何会有此文" class="headerlink" title="为何会有此文"></a>为何会有此文</h2><p>2016年中曾经劝过身边的好朋友买房，2017年底发现漏通知了一位，之后说起十分尴尬，“我去，你怎么没跟我说！”此文既是为了防止这种情况的再次发生。</p><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p>敝人预计19年房价还会继续下跌，可能性大于80%。下跌区域全国性，一线、准一线城市黄金地段不包括。</p><h2 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h2><h3 id="基本盘"><a href="#基本盘" class="headerlink" title="基本盘"></a>基本盘</h3><p>经济基础决定上层建筑，GDP增长率，股市，外贸等硬指标几乎都是可以预见的下降趋势。刺激经济增长的内生动力严重不足，人口红利消减，收入增长减缓，小企业生存困难国进民退，税收增长率远远高于GDP增长率，想像美国一样大规模减税在体制上就不可能发生。</p><p>唯一一个可能产生动力的源头一带一路，但我估计仅凭这一项就想抵消上面的全部颓势因素绝无可能。更别说领导同志大笔一挥债务减免挣来的钱可能就没了。当然这是一个百年大计，过分计较一时得失不可取，在此就不展开了。只讨论明年的可能情况。</p><p>政策上是否还有招可以创造内生动力？08年4万亿，19年20万亿行不行？这么做应当可以力挽狂澜，姑且可算在那剩下的20%可能性当中。永远不可高估中国人的下线，这是我在这个国度生活了30多年得出的最宝贵经验。</p><p>以上我得出的结论是经济增长进一步减缓。</p><h3 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h3><p>长久以来我国的货币发行依赖于（或者说绑定于）贸易的美元顺差，赚多少美元印多少人民币。为了对冲和维持汇率RMB长久以来不得不维持严重超发的状态。按照普通国家的来说产生的结果肯定是钱流向股市和房市，中国股市因其国情特殊性导致其一直以来扮演的角色就是中国智商税税务局。要我说中国股民（或者说中国人民）已经算是非常理智了，否则分分钟给你炒上天际。6000就能打住真是个奇迹，总结就是聪明人太多不好忽悠。</p><p>所以聪明的中国人选择（或者说被迫选择）了房地产，实在是无奈又聪明的举动。无奈是实在没有其他选择了，金融衍生品，民间借贷严格管控，贵金属本省就是抗风险产品。聪明是房产作为一种不动产实在特殊。生活必需品，土地是不可再生资源，特殊国情与城市户口相关进而与医疗，教育等其他生活必须资源相关，可以做杠杆，更重要的是有地方政府的信用做保证！而且不是保证你不变废纸，正常情况下就是保证你不会亏。</p><p>总之房地产在我国一直扮演着最重要也几乎就是唯一的货币蓄水池的作用。而随着贸易战的进行美元盈余必将进一步减少，目前我国的外汇储备官方数字近几月处于下降态势具体原因未知。因为正常来说下降应该在明年而不是今年，可能性很多背后可能有大棋不展开说。美元盈余减少，货币增发按照以往策略也应减缓，故支撑房价的因素又少一项。</p><h3 id="城市化"><a href="#城市化" class="headerlink" title="城市化"></a>城市化</h3><p>这是一个非常复杂的问题，我估计我国的智囊团也没有有把握的答案。敝人斗胆在这瞎猜一番。首先是现今的城市化率，各个机构的数字皆不相同，本来这个数字其实就是很难界定。多大县城可以算作城市，常驻人口算不算已经城市化，是不是一定要有住房才算。第二城市化那一年到多少算作基本完成，中国国情特殊，再加上互联网，物联网技术的增长未来城市可能与现今大不相同，也许未来不在需要城市化也说不定。第三存量住房究竟有多少？</p><p>在中国以上三个问题，我看在中国堪比哲学三大终极问题了。</p><p>因为此文讨论是房价的预期，以上三个问题我用一个回答回答：“我国的存量住房已经能够支持中国未来十年的城市化进程”说白了就是我国的空置房数量现今应该是一个非常恐怖的数字。</p><p>故我的观点是，只要政府愿意在不新建住房的情况下城市化的进程仍可继续。</p><h3 id="政府的目标"><a href="#政府的目标" class="headerlink" title="政府的目标"></a>政府的目标</h3><p>至此我认为影响房价的三个最大因素已经罗列完毕，1.经济大环境，2.超发的货币增量，3.城市化。这里在分析一下政府的需求，首先最重要的地方财政。如果房价不涨或者下跌地方财政必然难以为继，故要么维持房价要么寻找新的收入点（请不要问为什么政府不能勒紧裤腰带来支持民营经济这种问题）。我的答案是房产税。</p><p>次一级的需求是经济增长，本届政府是有大志向的。几个目标，世界级强国（世界第一），世界级强军，一带一路，国家统一。所有这些目标都必须有一个支撑点——钱。</p><p>理想中的中国经济增长模型应该是，城市化-&gt;房地产业-&gt;各行业-&gt;经济增长-&gt;就业收入增加-&gt;城市化。目前这个健康循环中的最大问题点就是高房价。高房价抑制了城市化，从而阻碍了整体的经济增长。但是房价降必然给地产行业带来打击，从而可能引发连锁反应给整体经济带来重创，陷入经济下降的恶性循环。世界上大部分国家都经历过这个痛苦的过程，经济危机。</p><p>所以现在政府或者说中国全体人民需要的是一个既能解决高房价，又能不影响整体经济，从而重新释放内生动力的方案。</p><p>那么真的有两全齐美的方法吗？当然没有！挖坑要填，欠债要还，天塌下来要人顶。</p><h3 id="房价下降的后果"><a href="#房价下降的后果" class="headerlink" title="房价下降的后果"></a>房价下降的后果</h3><p>说是下降，请理解成下降或崩溃。首先是房企，有地烂在手上的肯定倒闭，造成银行烂账。那么问题就是全国房企大规模倒闭造成的烂账银行撑得住吗？我觉得问题不大，几大国资银行天天盆满钵满，500强都是名列前茅，即使高管开的都是天价工资每年的利润率还是很好看。想当年国企改制那种洪水滔天的烂账都能解决，今天几个房企，少吃两顿可能裤腰带都不用勒就过去了。</p><p>接着是房地产相关行业，我觉得这部分问题就更不大了，政府年年喊着去产能，钢筋水泥首当其充。今年土地成交量已经大幅下降，整个行业已经做好了下降预期。打雷下雨，该回家收衣服的已经准备好了。</p><p>最后还有一个最大的问题，房贷断供。08年次贷危机说到底问题爆发点就在这上。经济下行房贷断供，贷款人申请破产，资产拍卖清偿资不抵债，拍卖增多房价下跌，金融衍生品亏损，连锁引爆次贷危机。</p><p>那么中国有可能发生一样的情况吗？首先国内没有基于房贷的金融衍生品。所以断供即是断供不会引发金融系统的系统性风险。（PS:话说我们有金融系统吗？）那么问题就剩下一个了，房价下跌引发的大规模断供会让银行崩溃吗？回答是肯定的，不会。告诉各位一个中国的基本事实，中国的房贷可没有强制平仓这一说。如果说美国的房贷是有限责任，即你还不上银行收回房子贷款清零。那么中国的房贷就是无限责任，100w的房子70w的贷款就算你房子跌到只剩30w，银行收回你的房子拍卖得了30w，剩下的70w贷款你还是得还。</p><p>如果你不知道上述事实，我建议再往下看之前先冷静思考五分钟。用世界上最强大的图像引擎，想象力，去想象一下那天崩地裂的景象。</p><h3 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h3><p>背着一套房的刚需继续还房贷。就算能承受的住征信出问题也绝对受不了上老赖名单。所以该还还得还。炒房客，不跳楼的都是内心强大的，中国人内心还是很强大所以问题不大。地产开发商终于经历了建国以来的一次正向竞争淘汰。去产能事业进步巨大。</p><p>总之房价的崩溃不会是全行业的系统性崩溃，结局会更像是针对中国刚刚生成的一部分中产阶级的一次定向爆破。说真的我真想看看到时候那帮砸售楼处的人，到时候准备去砸哪。</p><p>以上，歌照唱，舞照跳。天下无事，我说无事就无事。不想被代表的同志请早做打算。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>千古机遇，历史拐点。一手好牌想打错都难。一地鸡毛之后顺势出台房产税平衡地方财政，使地产行业成为真正服务于民生的行业。耕者有其田，居者有其屋，能者居其位，盛世开启。</p><p>广阔天地，大有可为，与君共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 妄人妄语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React、Vue比较</title>
      <link href="/react-vue-bi-jiao/"/>
      <url>/react-vue-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Vue-框架比较"><a href="#React-Vue-框架比较" class="headerlink" title="React Vue 框架比较"></a>React Vue 框架比较</h1><p>使用Vue全家桶开发有一年多时间，React三个月。说一点自己的感受。</p><p>总体上来说Vue 比 React要友好一些，React 则更加接近 JavaScript 语言原生状态。就个人来说先学习Vue，在使用了一段时间之后对其模板混合等概念无法很好的理解，官方文档不尽详细，阅读源码从效率上讲意义不大，导致想深入很难。</p><p>React 组件直接使用 Class 语法，方便理解，感觉开发过程当中和底层的距离更近。</p><h3 id="细节上一一分析"><a href="#细节上一一分析" class="headerlink" title="细节上一一分析"></a>细节上一一分析</h3><ol><li><p>文件</p><blockquote><p>  Vue的文件组成更加清晰，模板，JS，CSS分割清楚。React JSX 或 JS 基本混成一团，从开发体验上讲不如Vue。</p></blockquote></li><li><p>语法</p><blockquote><p>  最大的区别在于 Vue 的模板语言，和React的JSX。在大多数的简单场景下 Vue有更好的体验，v-if v-show等属性标记传承自 AngularJS，React 的 JSX 在复杂组件下有更好的表现因为是完全编程式的书写方式。但是Vue同样也有JSX的实现方式，所以从这点上来说Vue是完爆了 React。同时非常重要的一点Form表单的书写上Vue也是完爆了React，React的表单书写尤其复杂冗余。</p></blockquote></li><li><p>生态</p><blockquote><p>  就国内的开发环境来说就是Element-UI和Ant-Design的对比。不是我对阿里有成见，我实在是不清楚Ant-Design的团队在想什么，做UI组件库何不专注做好这一件事。非要在项目脚手架上做文章，做文章不是原罪，做的差还乱改就是罪上加罪了。</p></blockquote><blockquote><p>  先是做了一个roadhog的脚手架，本意是好的简化项目搭建流程。但是做了一半丢着不管，扩展性又非常差，有些特殊需求就抓虾了，还是得自己从头webpack一步步从新构建开发编译环境。</p></blockquote><blockquote><p>  做了一半丢着不管之后是怎样？在挖一个更大的坑，新版的演示项目使用UMI，项目耦合程度比上一个单纯的编译工具更高，直接和开发源码耦合，用了就别想退回 webpack原生了，真不知是怎么想的，你们是想卖授权吗？</p></blockquote><blockquote><p>  Elment团队在这点上做的就很好，一句话不做多余的事，直接给一个webpack的最佳实践，大家照抄就行了。</p></blockquote><blockquote><p>  从UI组件库的完成度上来讲也是Element更高。</p></blockquote></li></ol><p>综上所述，单纯的Web开发来讲，我强烈推荐Vue学习曲线平滑，也留下了可以深入的空间，生态上也好于React，唯一的弱项在于native开发，但是近期由于Airbnb 对React-native的放弃，个人也不看好JS技术一统原生江湖的未来，天下大势合久必分，分久必合。个人看好将来Vue一统江湖。但是原生估计没希望了，PS：微信小程序 前端工程师的灾难。</p>]]></content>
      
      
      <categories>
          
          <category> 技术日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EmacsIDEAs</title>
      <link href="/emacsideas/"/>
      <url>/emacsideas/</url>
      
        <content type="html"><![CDATA[<p>EmacsIDEAs ideas 插件，非常方便的 edit 跳转</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图文开发计划</title>
      <link href="/tu-wen-kai-fa-ji-hua/"/>
      <url>/tu-wen-kai-fa-ji-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="文字编辑功能完全定制"><a href="#文字编辑功能完全定制" class="headerlink" title="文字编辑功能完全定制"></a>文字编辑功能完全定制</h3><blockquote><p><strong>一阶段</strong><br>预计时间：5天</p></blockquote><ul><li style="list-style: none"><input type="checkbox" checked></input> 编辑区域覆盖实际区域</li><li style="list-style: none"><input type="checkbox" checked></input> 编辑按钮定制</li><li style="list-style: none"><input type="checkbox" checked></input> focus框体实时更新</li></ul><blockquote><p><strong>二阶段</strong><br>预计时间：3天</p></blockquote><ul><li><p>针对所有区域元素的文字完全编辑功能</p><blockquote><p><em>需要抽取编辑区域元素的计算属性，加入到编辑环境</em></p></blockquote></li><li><p>文字颜色及背景色的修改</p><blockquote><p><em>同上需要抽取欲编辑区域的计算属性</em></p></blockquote></li></ul><h3 id="定制特殊区域编辑"><a href="#定制特殊区域编辑" class="headerlink" title="定制特殊区域编辑"></a>定制特殊区域编辑</h3><blockquote><p>预计时间：5天</p></blockquote><ul><li>特定区域的背景色替换变更</li><li>边框样式调整</li><li>图片宽度百分比调整</li><li>透明度、旋转角度调整</li><li>点击事件设置</li><li>……</li></ul><h3 id="模块拖拽功能"><a href="#模块拖拽功能" class="headerlink" title="模块拖拽功能"></a>模块拖拽功能</h3><blockquote><p>预计时间：5天</p></blockquote><ul><li>通过拖拽的方式添加调整模块位置</li></ul><h3 id="前进后退功能"><a href="#前进后退功能" class="headerlink" title="前进后退功能"></a>前进后退功能</h3><blockquote><p>预计时间：3天</p></blockquote><ul><li>尽量放在开发最后期</li></ul><h3 id="模板后端存储"><a href="#模板后端存储" class="headerlink" title="模板后端存储"></a>模板后端存储</h3><blockquote><p>待讨论</p></blockquote><h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h3 id="focus-hover-框体样式完美化"><a href="#focus-hover-框体样式完美化" class="headerlink" title="focus hover 框体样式完美化"></a>focus hover 框体样式完美化</h3><ul><li>focus 状态下hover框体呈现不同样式</li><li>focus 框体圆角矩形贴合</li></ul><h3 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a>按键绑定</h3><ul><li>del</li><li>ctrl + enter</li></ul>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
